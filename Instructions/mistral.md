Hey Claude, This is the documentation of Mistral AI Documentation. Covering model training processess and model architecture in detail with advance and technical information.

Bienvenue to Mistral AI Documentation
Mistral AI is a research lab building the best open source models in the world. La Plateforme enables developers and enterprises to build new products and applications, powered by Mistral’s open source and commercial LLMs.

Mistral AI Large Language Models (LLMs)
We release both premier models and free models, driving innovation and convenience for our developer community. Our models are state-of-the-art for their multilingual, code generation, maths, and advanced reasoning capabilities.

Premier models
Mistral Medium, a state-of-the-art model perfectly balancing frontier-class multimodal performance with size and pricing, was released May 2025
Codestral, our cutting-edge language model for coding with the latest version released January 2025
Mistral OCR, our OCR service that enables our users to extract interleaved text and images released May 2025
Mistral Saba, a leader in small models category trained extensively on languages from the Middle East and South Asia released February 2025
Mistral Large, our top-tier reasoning model for high-complexity tasks with the lastest version released November 2024
Pixtral Large, our frontier-class multimodal model released November 2024
Ministral 3B, world’s best edge model released October 2024
Ministral 8B, powerful edge model with extremely high performance/price ratio released October 2024
Mistral Embed, our state-of-the-art semantic for extracting representation of text extracts
Mistral Moderation, our moderation service that enables our users to detect harmful text content
Free models
Mistral Small, a new multimodal leader in the small models category with the lastest version v3.1 released March 2025
Devstral Small, a new SOTA coding model that excels at using tools to explore codebases, editing multiple files and power software engineering agents released May 2025
Pixtral, a 12B model with image understanding capabilities in addition to text released September 2024
Mistral NeMo, a powerfull open source model released July 2024
Codestral Mamba, our first mamba 2 open source model released July 2024
Mathstral 7b, our first math open source model released July 2024
Learn more about our models here.

Explore the Mistral AI APIs
The Mistral AI APIs empower LLM applications via:

Text generation, enables streaming and provides the ability to display partial model results in real-time
Vision, enables the analysis of images and provides insights based on visual content in addition to text.
OCR, allows the extraction of interleaved text and images from documents.
Code generation, enpowers code generation tasks, including fill-in-the-middle and code completion.
Embeddings, useful for RAG where it represents the meaning of text as a list of numbers.
Function calling, enables Mistral models to connect to external tools.
Citations, allows the output of citations for RAG use cases.
Structured Outputs, enables Mistral models to have structured or json outputs.
Fine-tuning, enables developers to create customized and specialized models.
Guardrailing, enables developers to enforce policies at the system level of Mistral models.


Benchmarks
LLM (Large Language Model) benchmarks are standardized tests or datasets used to evaluate the performance of large language models. These benchmarks help researchers and developers understand the strengths and weaknesses of their models and compare them with other models in a systematic way.

Mistral benchmarks
Mistral demonstrates top-tier reasoning capabilities and excels in advanced reasoning, multilingual tasks, math, and code generation. The company reports benchmark results on popular public benchmarks such as MMLU (Massive Multitask Language Understanding), MT-bench, and others.

You can find the benchmark results in the following blog posts:

Magistral Medium: Our frontier-class reasoning model built on top of Mistral Medium 3, offering state-of-the-art reasoning capabilities for enterprise use cases.
Magistral Small: Our small reasoning model built on top of Mistral Small 3, a compact open model with high-performance reasoning.
Mistral Medium: A cutting-edge multimodal model. It can be used for professional use cases, coding, function-calling and reasoning tasks.
Pixtral Large: Pixtral Large is a 124B open-weights multimodal model built on top of Mistral Large 2. It is the second model in our multimodal family and demonstrates frontier-level image understanding.
Pixtral 12B: Pixtral 12B the first open-source model to demonstrate state-of-the-art multimodal understanding, without regressing on abilities in pure text.
Mistral Large: A cutting-edge text generation model with top-tier reasoning capabilities. It can be used for complex multilingual reasoning tasks, including text understanding, transformation, and code generation.
Mistral Small: A powerful and efficient multimodal model with high level conversational and translation capabilities.
Devstral Small: A powerful and efficient 24B text model. Debuting as #1 open source model on SWE-bench. This model has high agentic capabilities, performing well with OpenHands and SWE-agent code agent frameworks.
Mistral Saba: A powerful and efficient text generation model trained extensively on languages from the Middle East and South Asia, achieving state-of-the-art quality comparable to much larger models. It can be used for complex multilingual reasoning tasks, including text understanding, transformation, and code generation.
Mistral Nemo: Mistral Nemo's reasoning, world knowledge, and coding performance are state-of-the-art in its size category. As it relies on standard architecture, Mistral Nemo is easy to use and a drop-in replacement in any system using Mistral 7B that it supersedes.
Codestral: Codestral sets a new standard on the performance/latency space for code generation compared to previous models used for coding.
Codestral-Mamba: we have trained this model with advanced code and reasoning capabilities, enabling the model to have a strong performance on par with SOTA transformer-based models.
Mathstral: Mathstral stands on the shoulders of Mistral 7B and specialises in STEM subjects. It achieves state-of-the-art reasoning capacities in its size category across various industry-standard benchmarks.
Mixtral 8x22B: our most performant open model. It handles English, French, Italian, German, Spanish and performs strongly on code-related tasks. Natively handles function calling.
Mixtral 8x7B: outperforms Llama 2 70B on most benchmarks with 6x faster inference and matches or outperforms GPT3.5 on most standard benchmarks. It handles English, French, Italian, German and Spanish, and shows strong performance in code generation.
Mistral 7B: outperforms Llama 2 13B on all benchmarks and Llama 1 34B on many benchmarks.
Scale Seal Leaderboard
Scale AI reports private benchmark results in coding, instruction following, math, and Spanish. Mistral Large performs exceptionally well in code and Spanish, outperforming Llama 3 405B in these areas.

Artificial Analysis
Artificial Analysis compares and evaluates AI models across key performance metrics, including quality, price, output speed, latency, context window, and others. Our model has several areas of outstanding performance worth highlighting.

Artificial Analysis Quality Index: Our model ranks 3rd in this benchmark, surpassing even the 405B model. This achievement underscores our model's superior ability to analyze and generate high-quality insights.
Coding (HumanEval): In the HumanEval benchmark, our model secures the 3rd position, again outperforming the 405B model. This highlights our model's exceptional proficiency in coding tasks.
Quantitative Reasoning (MATH): Our model places 4th in the MATH benchmark, ahead of the 405B model. This demonstrates our model's strong quantitative reasoning capabilities.
Scientific Reasoning & Knowledge (GPQA): In the GPQA benchmark, our model ranks 4th, showcasing its robust scientific reasoning and knowledge retention abilities.
Qualitative feedback
We've gathered a lot of valuable insights from platforms like Reddit and Twitter. Below are some highlights and quotes from users who have shared their experiences with our models.

Pixtral:
Pixtral absolutely SLAYS at OCR.

Very impressive at charts and diagrams and drawings and photos of screens.

It outperforms GPT-4o-mini in many examples I’ve tested.

Mistral Large:
Mistral large 2 has been my go to model.

This model is so good. In terms of local models, this is probably the first that I honestly felt was proprietary tier for coding.

Mistral Nemo:
I’ve been playing with Nemo for a few days now, and it blows me away at how coherent it is. It’s slightly ‘less creative and more repetitive’ than Llama 3 8B fine-tunes… But it feels ‘more coherent and has better instruction capabilities’.

Just wanna say thank you to those genius french over at Mistral for Nemo. 12B parameters and 128k context is a very useful combination. It’s enough of a size improvement over 7B to feel a little more “solid” when talking to it, and it runs circles around Llama-2-13B, with 32x the context length. Thank you mistral!

Previous
Models Overview


Model selection
This guide will explore the performance and cost trade-offs, and discuss how to select the appropriate model for different use cases. We will delve into various factors to consider, offering guidance on choosing the right model for your specific needs.

Today, Mistral models are behind many LLM applications at scale. Here is a brief overview on the types of use cases we see along with their respective Mistral model:

Simple tasks that one can do in bulk (Classification, Customer Support, or Text Generation) can be powered by Mistral Nemo.
Intermediate tasks that require moderate reasoning (Data extraction, Summarizing a Document, Writing emails, Writing a Job Description, or Writing Product Descriptions) are powered by Mistral Small.
Complex tasks that require large reasoning capabilities or are highly specialized (Synthetic Text Generation, Code Generation, RAG, or Agents) are powered by Mistral Large.
Our Legacy models can currently be replaced by our more recent, high-quality models. If you are considering an upgrade, here are some general comments that may assist you:

Mistral Nemo currently outperforms Mistral 7B and is more cost-effective.
Mistral Small currently outperforms Mixtral 8x7B and is more cost-effective.
Mistral Large currently outperforms Mixtral 8x22B while maintaining the same price ratio.
Performance and cost trade-offs
When selecting a model, it is essential to evaluate the performance, and cost trade-offs. Depending on what’s most important for your application, your choice may differ significantly. Note that the models will be updated over time, the information we share below only reflect the current state of the models.

Notably, Mistral Large v2 is currently outperforming all of our other models across almost all benchmarks. By considering the performance, speed, and cost details, hopefully you can find the best model that suits your application's needs.

As a general rule, if you are new to using Large Language Models, you can always start with Mistral Large first. This will allow you to evaluate its cost and performance and determine whether you need to downgrade to Mistral Small or even Mistral Nemo. If you are already using another large language model and are looking to replace a particularly powerful one, then Mistral Large may be the best choice for you.

Use cases
Mistral Nemo: Simple tasks that one can do in bulk
Mistral Nemo is the ideal choice for simpe tasks that one can do in builk - like Classification, Customer Support, or Text Generation. It offers excellent performance at an affordable price point. For instance, it can be effectively used for a classification task to classify if an email is spam or not:

Prompt:

Classify the following email to determine if it is spam or not. Only respond with the exact words "Spam" or "Not spam".

🎉 Urgent! You've Won a $1,000,000 Cash Prize! 💰 To claim your prize, please click on the link below: https://bit.ly/claim-your-prize

All of our models can accurately classify this email correctly as “Spam”. Mistral Nemo is capable to provide the correct classification as the larger models. So it is the most efficient and affordable choice for this kind of tasks.

Mistral Small: Intermediate tasks that require language transformation
Mistral Small is the ideal for intermediate tasks that require moderate reasoning - like Data extraction, Summarizing a Document, Writing a Job Description, or Writing Product Descriptions. Mistral Small strikes a balance between performance and capability, making it suitable for a wide range of tasks that only require language transformaion. For example, Mistral Small can write an email:

Prompt:

Compose a welcome email for new customers who have just made their first purchase with your product. 
Start by expressing your gratitude for their business, and then convey your excitement for having them as a customer. 
Include relevant details about their recent order. Sign the email with "The Fun Shop Team".

Order details:
- Customer name: Anna
- Product: hat 
- Estimate date of delivery: Feb. 25, 2024
- Return policy: 30 days

Output:

Subject: Welcome to The Fun Shop, Anna! Your Hat is on its Way!

Dear Anna,

We hope this message finds you well. We are thrilled to welcome you to The Fun Shop family! We are incredibly grateful for your business and are excited to have you as our new customer.

We are processing your recent order for the fabulous hat you've selected. Your new accessory is set to be delivered by Feb. 25, 2024. We hope it arrives just in time to add a touch of fun and style to your outfits!

Please remember that our return policy allows you to return any item within 30 days of receipt if you are not completely satisfied. We want you to love every item you purchase from us, so if there's any issue, please don't hesitate to reach out.

Thank you once again for choosing The Fun Shop. We look forward to serving you and making your shopping experience a fun and enjoyable one!

Best Regards,
The Fun Shop Team

Mistral Large: Complex tasks that require large reasoning capabilities or are highly specialized
Mistral Large is ideal for complex tasks that require large reasoning capabilities or are highly specialized - like Synthetic Text Generation, Code Generation, RAG, or Agents.

Complex reasoning
Mistral Large outperforms our other four models in commonsense and reasoning benchmarks, making it the best choice for complex reasoning tasks.

In this example, we ask Mistral Large to calculate the difference in payment dates between the two customers whose payment amounts are closest to each other in the given dataset. Mistral Large can easily and automatically break down the problem into smaller steps: identify the two closest payment amounts, find their respective payment dates, and calculate the date difference. Mistral Large is an excellent choice for tasks that require complex reasoning and problem-solving skills.

Prompt:

Calculate the difference in payment dates between the two customers whose payment amounts are closest to each other in the given dataset: 

'{
  "transaction_id":{"0":"T1001","1":"T1002","2":"T1003","3":"T1004","4":"T1005"},
    "customer_id":{"0":"C001","1":"C002","2":"C003","3":"C002","4":"C001"},
    "payment_amount":{"0":125.5,"1":89.99,"2":120.0,"3":54.3,"4":210.2},
"payment_date":{"0":"2021-10-05","1":"2021-10-06","2":"2021-10-07","3":"2021-10-05","4":"2021-10-08"},
    "payment_status":{"0":"Paid","1":"Unpaid","2":"Paid","3":"Paid","4":"Pending"}
}'

Output:

To find the difference in payment dates between the two customers whose payment amounts are closest to each other, we first need to identify the two closest payment amounts and then find their respective payment dates.

The payment amounts are: 125.5, 89.99, 120.0, 54.3, 210.2

The two closest payment amounts are 125.5 and 120.0. The payment date for the payment amount 125.5 is '2021-10-05' and for the payment amount 120.0 is '2021-10-07'.

The difference in payment dates can be calculated as follows:

Date difference = |'2021-10-07' - '2021-10-05'| = 2 days

So, the difference in payment dates between the two customers whose payment amounts are closest to each other is 2 days.

Let’s try another prompt we found online that requires reasoning and logic understanding. Mistral Large is able to answer it correctly.

Prompt:

There's an apple inside a blue box. There's also a red box inside the blue box. The red box has a lid on it. How can I get the apple?

Output:

You can get the apple by opening the blue box. The apple is not inside the red box, so you don't need to open the red box. Simply reach into the blue box and take the apple.

Here is another example. Mistral Large is able to answer it correctly.

Prompt:

Which one is heavier a pound of iron or a kilogram of feather

Output:

A kilogram of feathers is heavier than a pound of iron.

A pound is a unit of weight that is equivalent to approximately 0.453592 kilograms. Therefore, a pound of iron weighs less than a kilogram of feathers.

It may seem counterintuitive because we often think of iron as being a heavy material and feathers as being light, but the weight of an object depends on its mass and the force of gravity acting upon it, not on its material or composition.

Coding
Mistral Large, the top performer in coding tasks, is the ideal choice for users who priortize coding capabilities in their model selection.

Here is an example of Mistral Large giving the correct code following the prompt.

Prompt:

Write a function to find the maximum number of segments of lengths a, b and c that can be formed from n.

Output:

# Here is a possible function in Python to find the maximum number of segments that can be formed from a given length `n` using segments of lengths `a`, `b`, and `c`:

def max_segments(n, a, b, c):
    # Initialize the maximum number of segments to 0
    max_num_segments = 0

    # Loop through all possible combinations of segments
    for i in range(n // a + 1):
        for j in range(n // b + 1):
            for k in range(n // c + 1):
                # Check if the combination is valid and update the maximum number of segments
                if i * a + j * b + k * c == n:
                    max_num_segments = max(max_num_segments, i + j + k)

    return max_num_segments

# This function uses nested loops to generate all possible combinations of segments of lengths `a`, `b`, and `c`, respectively. For each combination, it checks if the total length of the segments is equal to `n`, and if so, it updates the maximum number of segments found so far. The function returns the maximum number of segments that can be formed from `n`.

Here is another example of Mistral Large writing a function for computing square roots using the babylonian method.

Prompt:

You are an expert Python programmer, and here is your task: Write a function for computing square roots using the babylonian method. Your code should pass these tests:

assert math.isclose(babylonian_squareroot(10), 3.162277660168379, rel_tol=0.001)
assert math.isclose(babylonian_squareroot(2), 1.414213562373095, rel_tol=0.001)
assert math.isclose(babylonian_squareroot(9), 3.0, rel_tol=0.001)

Output:

def babylonian_squareroot(number):
    if(number == 0):
        return 0;
    g = number/2.0;
    g2 = g + 1;
    while(g != g2):
        n = number/ g;
        g2 = g;
        g = (g + n)/2;
    return g;"

Multi-lingual tasks
In addition to its exceptional performance in complex reasoning tasks and coding tasks, Mistral Large also demonstrates superior capabilities in handling multi-lingual tasks. Mistral-large has been specifically trained to understand and generate text in multiple languages, especially in French, German, Spanish and Italian. Mistral Large can be especially valuable for businesses and users that need to communicate in multiple languages.

Prompt:

Lequel est le plus lourd une livre de fer ou un kilogramme de plume

Output:

Un kilogramme de plumes est plus lourd qu'une livre de fer.

Pour comprendre cela, il est important de se rappeler que :

1. Une livre (lb) est une unité de mesure de masse principalement utilisée aux États-Unis et dans d'autres systèmes de mesure impériaux, tandis qu'un kilogramme (kg) est l'unité de base de masse dans le système international d'unités (SI).
2. 1 kilogramme est approximativement égal à 2,2 livres.

Donc, un kilogramme de plumes est plus lourd qu'une livre de fer, car il correspond à environ 2,2 livres de plumes.

Model weights
We open-source both pre-trained models and instruction-tuned models. These models are not tuned for safety as we want to empower users to test and refine moderation based on their use cases. For safer models, follow our guardrailing tutorial.

License
Mistral 7B, Mixtral 8x7B, Mixtral 8x22B, Codestral Mamba, Mathstral, Mistral Nemo, Pixtral 12B, Mistral Small, Magistral Small and Devstral Small are under Apache 2 License, which permits their use without any constraints.
Codestral is under Mistral AI Non-Production (MNPL) License.
Ministral 8B, Mistral Large, and Pixtral Large are under Mistral Research License.
note
If you are interested in purchasing a commercial license for our models, please contact our team

Downloading
Model	Download links	Features
Magistral-Small-2507	Hugging Face	- 128k vocabulary size
- Supports v7 tekken.json tokenizer
Voxtral-Small-24B-2507	Hugging Face	- 128k vocabulary size
- Supports v11 tekken.json tokenizer
- Supports function calling
- Supports audio
Voxtral-Mini-3B-2507	Hugging Face	- 128k vocabulary size
- Supports v11 tekken.json tokenizer
- Supports function calling
- Supports audio
Devstral-Small-2507	Hugging Face	- 128k vocabulary size
- Supports v7 tekken.json tokenizer
- Supports function calling
Mistral-Small-Instruct-2506	Hugging Face	- 128k vocabulary size
- Supports v11 tekken.json tokenizer
- Supports function calling
- Supports images
Magistral-Small-2506	Hugging Face	- 128k vocabulary size
- Supports v7 tekken.json tokenizer
Devstral-Small-2505	Hugging Face	- 128k vocabulary size
- Supports v7 tekken.json tokenizer
- Supports function calling
Mistral-Small-Instruct-2503	Hugging Face	- 128k vocabulary size
- Supports v7 tekken.json tokenizer
- Supports function calling
- Supports images
Mistral-Small-Base-2503	Hugging Face	- 128k vocabulary size
- Supports v7 tekken.json tokenizer
- Supports function calling
- Supports images
Mistral-Small-Instruct-2501	Hugging Face	- 128k vocabulary size
- Supports v7 tekken.json tokenizer
- Supports function calling
Mistral-Small-Base-2501	Hugging Face	- 128k vocabulary size
- Supports v7 tekken.json tokenizer
- Supports function calling
Pixtral-Large-Instruct-2411	Hugging Face	- 32768 vocabulary size
- Supports v7 tokenizer
- Supports function calling
- Supports images
Mistral-Large-Instruct-2411	Hugging Face	- 32768 vocabulary size
- Supports v7 tokenizer
- Supports function calling
Ministral-8B-Instruct-2410	Hugging Face	- 128k vocabulary size
- Supports v3 tekken.json tokenizer
- Supports function calling
Mistral-Small-Instruct-2409	Hugging Face	- 32768 vocabulary size
- Supports v3 Tokenizer
- Supports function calling
Pixtral-2409	Hugging Face	- 128k vocabulary size
- Supports v3 tekken.json tokenizer
- Supports function calling
- Supports images
Mistral-Large-Instruct-2407	Hugging Face
raw_weights (md5sum: fc602155f9e39151fba81fcaab2fa7c4)	- 32768 vocabulary size
- Supports v3 Tokenizer
- Supports function calling
Mistral-Nemo-Instruct-2407	Hugging Face
raw_weights (md5sum: 296fbdf911cb88e6f0be74cd04827fe7)	- 128k vocabulary size
- Supports v3 tekken.json tokenizer
- Supports function calling
Mistral-Nemo-Base-2407	Hugging Face
raw_weights (md5sum: c5d079ac4b55fc1ae35f51f0a3c0eb83)	- 128k vocabulary size
- Supports v3 tekken.json tokenizer
Mathstral-7B-v0.1	Hugging Face
raw_weights (md5sum: 5f05443e94489c261462794b1016f10b)	- 32768 vocabulary size
- Supports v3 Tokenizer
Codestral-Mamba-7B-v0.1	Hugging Face
raw_weights (md5sum: d3993e4024d1395910c55db0d11db163)	- 32768 vocabulary size
- Supports v3 Tokenizer
Codestral-22B-v0.1	Hugging Face
raw_weights (md5sum: 1ea95d474a1d374b1d1b20a8e0159de3)	- 32768 vocabulary size
- Supports v3 Tokenizer
Mixtral-8x22B-v0.3	raw_weights (md5sum: a2fa75117174f87d1197e3a4eb50371a)	- 32768 vocabulary size
- Supports v3 Tokenizer
Mixtral-8x22B-Instruct-v0.1/
Mixtral-8x22B-Instruct-v0.3	Hugging Face
raw_weights (md5sum: 471a02a6902706a2f1e44a693813855b)	- 32768 vocabulary size
Mixtral-8x22B-v0.1	Hugging Face
raw_weights (md5sum: 0535902c85ddbb04d4bebbf4371c6341)	- 32k vocabulary size
Mixtral-8x7B-Instruct-v0.1	Hugging Face
raw_weights (md5sum: 8e2d3930145dc43d3084396f49d38a3f)	- 32k vocabulary size
- Rope Theta = 1e6
Mixtral-8x7B-v0.1	Hugging Face	- 32k vocabulary size
- Rope Theta = 1e6
Mistral-7B-Instruct-v0.3	Hugging Face
raw_weights (md5sum: 80b71fcb6416085bcb4efad86dfb4d52)	- Extended vocabulary to 32768
- Supports v3 Tokenizer
- Supports function calling
Mistral-7B-v0.3	Hugging Face
raw_weights (md5sum: 0663b293810d7571dad25dae2f2a5806)	- Extended vocabulary to 32768
Mistral-7B-Instruct-v0.2	Hugging Face
raw_weights (md5sum: fbae55bc038f12f010b4251326e73d39)	- 32k vocabulary size
- Rope Theta = 1e6
- No sliding window
Mistral-7B-Instruct-v0.1	Hugging Face	- 32k vocabulary size
- Rope Theta = 1e4
- With sliding window
Mistral-7B-v0.1	Hugging Face
raw_weights (md5sum: 37dab53973db2d56b2da0a033a15307f)	- 32k vocabulary size
- Rope Theta = 1e4
- With sliding window
Sizes
Name	Number of parameters	Number of active parameters	Min. GPU RAM for inference (GB)
Mistral-7B-v0.3	7.3B	7.3B	16
Mixtral-8x7B-v0.1	46.7B	12.9B	100
Mixtral-8x22B-v0.3	140.6B	39.1B	300
Codestral-22B-v0.1	22.2B	22.2B	60
Codestral-Mamba-7B-v0.1	7.3B	7.3B	16
Mathstral-7B-v0.1	7.3B	7.3B	16
Mistral-Nemo-Instruct-2407	12B	12B	28 - bf16
16 - fp8
Mistral-Large-Instruct-2407	123B	123B	250
Pixtral-2409	12B	12B	28 - bf16
16 - fp8
Mistral-Small-2409	22B	22B	60
Ministral-8B-2410	8B	8B	24
Mistral-Large-Instruct-2411	123B	123B	250
Pixtral-Large-Instruct-2411	124B	124B	250
Mistral-Small-Base-2501	24B	24B	60
Mistral-Small-Instruct-2501	24B	24B	60
Mistral-Small-Base-2503	24B	24B	60
Mistral-Small-Instruct-2503	24B	24B	60
Devstral-Small-2505	24B	24B	60
Mistral-Small-Instruct-2506	24B	24B	60
Devstral-Small-2507	24B	24B	60
Voxtral-Small	24B	24B	60
Voxtral-Mini	3B	3B	8
How to run?
Check out mistral-inference, a Python package for running our models. You can install mistral-inference by

pip install mistral-inference

To learn more about how to use mistral-inference, take a look at the README and dive into this colab notebook to get started:


Model customization
Otherwise known as "How to Build an Application with a Custom Model"
Overview
The following is a quick guide on how to build an application with a custom model. Our goal is to help developers build product operations for LLMs to go from a prototype to deployment.

AI is a tool, building applications that harness AI make them more useful and practical to your end users.

Before LLMs, AI applications were built around personalization, precision, and prediction. Traditional AI applications are catered towards predicting your next choice and recommending it to you based on your previous behavior and “customers like you”.

In contrast, LLM applications are built around Human-AI collaboration. As a developer and the end user, you have more agency in the customisation of your product. You can create something that did not exist before.

Applications built with custom LLMs require an iterative development cycle, relying on continuous end user feedback and rigorous evals to ensure that your custom model behavior is aligned to the intended application behavior.

Key terms
Before we get started, let’s define key terms:

Application behavior can be defined as the user interaction. It takes into account usability, performance, safety, and adaptability. Application behavior includes Objectives and Values.

Model behavior can be defined as the expected, appropriate, and acceptable way of an LLM acting in a specific context or application boundaries. Model behavior includes Objectives and Values.

Objectives determine whether the model behavior is in line with the expected application behavior.

Values denotes the developers’ intended policy for the model and application. This can be a set of rules, a Constitution, or even a fictional character’s morals.

Steerability: three methods
There are several techniques (with varying levels of engineering complexity) available to steer model behavior within your application context. We recommend leveraging the three methods below to do so:

System prompt
Tune a model
Deploy a moderation layer for input/output processing
A System Prompt is a method to provide context, instructions, and guidelines to your model before the model is tasked with user input data (prompt guide). By using a system prompt, you can steer the model to better align to your intended product behavior - whether the application is a conversation or task, you can specify a persona, personality, tone, values, or any other relevant information that may help your model better perform in response to the end user’s input.

System prompts can include:

Clear and specific instructions and objectives
Roles, desired persona and tone
Guidance on style e.g. verbosity constraints
Value definitions e.g. policies, rules and safeguards
Desired output format
Tuning a model is a method to train the model on your intended application behavior (fine-tuning guide). Two popular approaches for tuning LLMs:

Application tuning, where you leverage a dataset of examples specified to the desired behavior of your application.
Safety tuning, where you leverage a dataset that specifies both example inputs that might result in unsafe behavior, along with the desired safe output in that situation.
Deploying a classifier for content moderation is a third method to create guardrails for your model’s behavior within the application. This is considered an extra security measure in case you are deploying your application to end users.

Guide for tuning a model to your intended application behavior
Step 1: Define your intended Application Behavior
The first step is to define the Objectives, i.e. how you want users to interact with your LLM product.

For inspiration, look to developers building with Mistral models:

standalone products like conversational assistants;
within pre-existing products to complete a specific task like “Summarize” or “Translate” or enable new capabilities like function calling with API access for “Knowledge retrieval”.
Learn how others are building products with custom models here: developer examples.

Step 2: Define your policies based on your Values
When you deploy an LLM within an end-user facing application, you identify which Values the model will need to abide by in order to meet your Content Moderation guidelines along with your user expectations.

For Content Moderation, look for inspiration from Llama Guard’s categories like Privacy, Hate, and Specialized Advice and ML Commons Taxonomy categories like CSAM and Hate.

Step 3: Create your Application Evals
The goal of your evals is to enable you to have better signal on whether your custom model’s behavior will meet your Application behavior before deployment. Identifying how you want to evaluate your custom model will help determine the type of training data to include in the fine-tuning.

There are two methods to evaluate an LLM:

Automated Evals
Metrics-based, similar to the public benchmark evaluations where you can derive a metric from pre-annotated data for example.
LLM-based, where you leverage a different LLM like Mistral Large to evaluate or judge the output of your custom model.
Human-based Evals, where you employ Content Annotators to evaluate or judge the output of your custom model and collect Human annotations.
For more on how to conduct an LLM Evaluation, check out our evaluation guide.

Step 4: Test your application behavior hypothesis with an MVP powered by Mistral Large
Once you understand the intent of your custom LLM and the contours of how you want the model to behave, begin by testing your application hypothesis with Mistral Large and collect the interaction data to better understand how your end users may interact with your LLM. For example, many developers begin their process by creating a Demo or MVP with limited access (a Private Beta).

For some applications, a system prompt is the best solution for an aligned model behavior. If you need help deciding between the two, look to our fine-tuning guide.

If a system prompt works creating a Custom Model, skip to Step 6.

Step 5: Tune for model alignment
Now that you have sense of the Application Behavior - Values and Objectives included - you are intending to adopt a custom model, you can begin the process of replacing Mistral Large for a smaller, custom model.

Look to our guide on how to prepare your Tuning dataset.

Areas to consider when preparing your Tuning Dataset for better model performance:

Data Comprehension, include all content policies for each application use case in your dataset (such as question-answering, summarization, and reasoning).
Data Variety, ensure dataset diversity across query length, structure, tone, topic, levels of complexity, and demographic considerations.
Deduplication, remove duplicates to prevent your tuning data being memorized.
Avoid Data Contamination, isolate evaluation data from the tuning dataset.
Ethical Data Practices, provide clear labeling guidelines and Annotator diversity to minimize model errors and bias.
For content moderation, get started with open source datasets like Safety-Tuned LlaMAs.

At Mistral, we support two ways to customize our models:

OSS with the FT Codebase
Via la Plateforme
Head to our FT API within la Plateforme, upload and validate your training data. Run the job, and when completed, you can access your custom model via your own model API endpoint.

Step 6: Test your custom model with your Evals
Now that you have your custom model API endpoint, you can run Application Evals from Step 4. Depending on your Application, remember to include Safety Evals in your Eval set:

Development Evaluations, include ongoing assessments during training and fine-tuning to compare model performance against launch criteria and evaluate the impact of mitigation strategies. These evaluations use adversarial queries or external academic benchmarks.
Assurance Evaluations, set up governance and review assessments at key milestones by an external group. These standardized evaluations use strictly managed datasets and provide high-level insights for mitigation efforts. They test safety policies and dangerous capabilities, such as biohazards, persuasion, and cybersecurity.
Red Teaming requires adversarial testing by specialist teams using less structured methods to discover potential weaknesses and improve risk mitigation and evaluation approaches.
External Evaluations, includes assessments by independent, external domain experts to identify model limitations and stress-test performance.
Based on the model performance, either retrain your model with new training data to support better model performance or deploy into your application by switching the Mistral Large API with your custom model endpoint.

Step 7: Once deployed, continuously monitor and update your custom model, evals, and testing based on real life application data
Congrats! You’ve deployed your custom model into your application.

Changelog
July 30, 2025

We released Codestral 2508 (codestral-2508).
July 24, 2025

We released Magistral Medium 1.1 (magistral-medium-2507) and Magistral Small 1.1 (magistral-small-2507).
We released a Document Library API to manage libraries.
SDK support for Audio and Transcription available.
July 15, 2025

We released our first Audio models for chat and a Transcription API:
Voxtral Small (voxtral-small-2507) available for chat use cases
Voxtral Mini (voxtral-mini-2507) available for chat use cases
Voxtral Mini Transcribe (voxtral-mini-2507 via audio/transcriptions) optimized for transcription
July 10, 2025

We released Devstral Small 1.1 (devstral-small-2507) and Devstral Medium (devstral-medium-2507).
June 23, 2025

Mistral Small 3.2 API available (mistral-small-2506).
June 20, 2025

We released Mistral Small 3.2.
June 10, 2025

We released Magistral Medium (magistral-medium-2506) and Magistral Small (magistral-small-2506).
May 28, 2025

We released Codestral Embed (codestral-embed).
May 27, 2025

We released the new Agents API.
May 22, 2025

We released Mistral OCR 2505 (mistral-ocr-2505) and annotations.
May 21, 2025

We released Devstral Small (devstral-small-2505).
May 7, 2025

We released Mistral Medium 3 (mistral-medium-2505).
April 16, 2025

We released the Classifier Factory.
March 17, 2025

We released Mistral Small 3.1 (mistral-small-2503).
March 6, 2025

We released Mistral OCR (mistral-ocr-2503) and document understanding.
February 17, 2025

We released Mistral Saba (mistral-saba-2502).
January 30, 2025

We released Mistral Small 3 (mistral-small-2501).
January 28, 2025

We released custom structured outputs for all models.
January 13, 2025

We released Codestral 2501 (codestral-2501).
November 18, 2024

We released Mistral Large 2.1 (mistral-large-2411) and Pixtral Large (pixtral-large-2411).
Le Chat:
Web search with citations
Canvas for ideation, in-line editing, and export
State of the art document and image understanding, powered by the new multimodal Pixtral Large
Image generation, powered by Black Forest Labs Flux Pro
Fully integrated offering, from models to outputs
Faster responses powered by speculative editing
November 6, 2024

We released moderation API and batch API.
We introduced three new parameters:
presence_penalty: penalizes the repetition of words or phrases
frequency_penalty: penalizes the repetition of words based on their frequency in the generated text
n: number of completions to return for each request, input tokens are only billed once.
November 6, 2024

We downscaled the temperature parameter of pixtral-12b, ministral-3b-2410, and ministral-8b-2410 by a multiplier of 0.43 to improve consistency, quality, and unify model behavior.
October 9, 2024

We released Ministral 3B (ministral-3b-2410) and Ministral 8B (ministral-8b-2410).
September 17, 2024

We released Pixtral (pixtral-12b-2409) and Mistral Small v24.09 (mistral-small-2409).
We reduced price on our flagship model, Mistral Large 2.
We introduced a free API tier on La Plateforme.
September 13, 2024

In le Chat, we added a mitigation against an obfuscated prompt method that could lead to data exfiltration, reported by researchers Xiaohan Fu and Earlence Fernandes. The attack required users to willingfully copy and paste adversarial prompts and provide personal data to the model. No user was impacted and no data was exfiltrated.
July 29, 2024

We released version 1.0 of our Python and JS SDKs with major upgrades and syntax changes. Check out our migration guide for details.
We released Agents API. See details here.
July 24, 2024

We released Mistral Large 2 (mistral-large-2407).
We added fine-tuning support for Codestral, Mistral Nemo and Mistral Large. Now the model choices for fine-tuning are open-mistral-7b (v0.3), mistral-small-latest (mistral-small-2402), codestral-latest (codestral-2405), open-mistral-nemo and , mistral-large-latest (mistral-large-2407)
July 18, 2024

We released Mistral Nemo (open-mistral-nemo).
July 16, 2024

We released Codestral Mamba (open-codestral-mamba) and Mathstral.
Jun 5, 2024

We released fine-tuning API. Check out the capability docs and guides.
May 29, 2024

New model available: codestral-latest (aka codestral-2405). Check out the code generation docs.
May 23, 2024

Function calling: tool_call_id is now mandatory in chat messages with the tool role.
Apr. 17, 2024

New model available: open-mixtral-8x22b (aka open-mixtral-8x22b-2404). Check the release blog for details.
For function calling, tool_call_id must not be null for open-mixtral-8x22b.
We released three versions of tokenizers for commercial and open-weight models: check the related guide and repo for more details.
Mar. 28, 2024

JSON mode now available for all models on La Plateforme.
Feb. 26, 2024

API endpoints: We renamed 3 API endpoints and added 2 model endpoints.

open-mistral-7b (aka mistral-tiny-2312): renamed from mistral-tiny. The endpoint mistral-tiny will be deprecated in three months.
open-mixtral-8x7B (aka mistral-small-2312): renamed from mistral-small. The endpoint mistral-small will be deprecated in three months.
mistral-small-latest (aka mistral-small-2402): new model.
mistral-medium-latest (aka mistral-medium-2312): old model. The previous mistral-medium has been dated and tagged as mistral-medium-2312. The endpoint mistral-medium will be deprecated in three months.
mistral-large-latest (aka mistral-large-2402): our new flagship model with leading performance.
New API capabilities:

Function calling: available for Mistral Small and Mistral Large.
JSON mode: available for Mistral Small and Mistral Large
La Plateforme:

We added multiple currency support to the payment system, including the option to pay in US dollars.
We introduced enterprise platform features including admin management, which allows users to manage individuals from your organization.
Le Chat:

We introduced the brand new chat interface Le Chat to easily interact with Mistral models.
You can currently interact with three models: Mistral Large, Mistral Next, and Mistral Small.
Jan. 11, 2024

We have enhanced the API's strictness. Previously the API would silently ignores unsupported parameters in the requests, but it now strictly enforces the validity of all parameters. If you have unsupported parameters in your request, you will see the error message "Extra inputs are not permitted".
A previous version of the guardrailing documentation incorrectly referred to the API parameter as safe_mode instead of safe_prompt. We corrected this in the documentation.
Jan. 16, 2024

We added token usage information in streaming requests. You can find it in the last chunk returned.

Glossary
LLM
LLMs (Large Language Models), such as the Mistral AI models, are AI models trained on extensive text data to predict the next word in a sentence. They are capable of understanding and generating text in a way that's similar to how humans communicate. They can answer questions, draft documents, summarize texts, extract information, translate languages, write code, and more.

Text generation
Text generation in large language models is the process of producing coherent and contextually relevant text based on a given input prompt. These models, such as Mistral AI, are trained on vast amounts of text data to predict the next word in a sentence, given the previous words as context. This capability enables them to generate text that is similar to human communication and can be used for various applications, including answering questions, drafting documents, summarizing texts, translating languages, and coding.

Tokens
Tokens serve as the smallest individual units that a language model processes, typically representing common sequences of characters such as words or subwords. In order for a language model to comprehend text, it must be converted into numerical representations. This is accomplished by encoding the text into a series of tokens, where each token is assigned a unique numerical index. The process of converting text into tokens is known as tokenization. One widely used tokenization algorithm is Byte-Pair Encoding (BPE), which initially treats each byte in a text as a separate token. BPE then iteratively adds new tokens to the vocabulary for the most frequent pair of tokens in the corpus, replacing occurrences of the pair with the new token, until no more replacements can be made. This results in a compact and efficient representation of the text for processing by the language model.

Mixture of Experts
Mixture of Experts (MoE) is the underlying architecture of Mixtral 8x7b and Mixtral 8x22b. It is a neural network architecture that incorporates expert layers within the Transformer block, allowing models to be pretrained with much less compute while maintaining the same quality as dense models. This is achieved by replacing dense feed-forward network (FFN) layers with sparse MoE layers, which contain multiple "experts" (FFNs). A gate network or router determines which input tokens are sent to which expert for computation. MoE offers benefits such as efficient pretraining and faster inference, but also presents challenges like overfitting during fine-tuning and high memory requirements. Nevertheless, MoE is a valuable method for achieving improved model quality at lower computing costs by dynamically assigning input tokens to specialized experts for processing.

RAG
Retrieval-augmented generation (RAG) is an AI framework that synergizes the capabilities of LLMs and information retrieval systems. There are two main steps in RAG: 1) retrieval: retrieve relevant information from a knowledge base with text embeddings stored in a vector store; 2) generation: insert the relevant information to the prompt for the LLM to generate information. RAG is useful to answer questions or generate content leveraging external knowledge including up-to-date information and domain-specific information. RAG allows the model to access and utilize information beyond its training data, reducing hallucination and improving factual accuracy. Check out our Basic RAG guide for details.

Fine-tuning
Fine-tuning is a process used in large language models to adapt a pre-trained model to a specific task or domain. It involves continuing the training process on a smaller, task-specific dataset and adjusting the model's parameters to optimize its performance on the new dataset. This enables the model to learn task-specific language patterns and improve its performance on the target task. Fine-tuning can be beneficial for adapting the model to a particular format or tone, domain-specific tasks, and improving performance through distillation from a larger model. This approach can achieve state-of-the-art performance with fewer data and computational resources compared to training a model from scratch.

Function calling
Function calling allows Mistral models to connect to external tools and call external functions or APIs to perform tasks beyond the model's capabilities. This allows the model to access and leverage external tools and resources to improve its performance and provide more accurate responses. Function calling can be used for tasks such as retrieving real-time data, performing calculations, accessing databases, and interacting with other systems or services. It improves the model's accuracy, efficiency, and versatility. Check out our Function Calling guide to learn more.

Embeddings
Embeddings are vectorial representations of text that capture the semantic meaning of paragraphs through their position in a high dimensional vector space. These vectors capture the semantic meaning and context of the text, allowing the model to understand and generate language more effectively. Mistral AI Embeddings API offers cutting-edge, state-of-the-art embeddings for text, which can be used for many NLP tasks. Check out our Embeddings guide to learn more.

Temperature
Temperature is a fundamental sampling parameter in LLMs that controls the randomness and diversity of the generated outputs. Lower Temperature values result in more deterministic and accurate responses, while higher values introduce more creativity and randomness. This parameter affects the softmax function, which normalizes logits into a probability distribution. Higher Temperatures flatten the distribution, making less likely tokens more probable, while lower Temperatures sharpen the distribution, favoring the most likely tokens. Adjusting the Temperature allows for tailoring the model's behavior to suit different applications, such as requiring high accuracy for tasks like mathematics or classification, or enhancing creativity for tasks like brainstorming or writing novels. Balancing creativity and coherence is crucial, as increasing Temperature can also introduce inaccuracies. Some models, such as pixtral-12b, ministral-3b-2410, ministral-8b-2410 and open-mistral-nemo have a factor of 0.43 on temperature when used via our services, to align better with how it impacts other models and unify model behaviour.


Text and Chat Completions
The Mistral models allows you to chat with a model that has been fine-tuned to follow instructions and respond to natural language prompts. A prompt is the input that you provide to the Mistral model. It can come in various forms, such as asking a question, giving an instruction, or providing a few examples of the task you want the model to perform. Based on the prompt, the Mistral model generates a text output as a response.

The chat completion API accepts a list of chat messages as input and generates a response. This response is in the form of a new chat message with the role "assistant" as output, the "content" of each response can either be a string or a list of chunks with different kinds of chunk types for different features. Visit our API spec for more details.

python
typescript
curl
No streaming

import os
from mistralai import Mistral

api_key = os.environ["MISTRAL_API_KEY"]
model = "mistral-large-latest"

client = Mistral(api_key=api_key)

chat_response = client.chat.complete(
    model = model,
    messages = [
        {
            "role": "user",
            "content": "What is the best French cheese?",
        },
    ]
)

print(chat_response.choices[0].message.content)

With streaming

import os
from mistralai import Mistral

api_key = os.environ["MISTRAL_API_KEY"]
model = "mistral-large-latest"

client = Mistral(api_key=api_key)

stream_response = client.chat.stream(
    model = model,
    messages = [
        {
            "role": "user",
            "content": "What is the best French cheese?",
        },
    ]
)

for chunk in stream_response:
    print(chunk.data.choices[0].delta.content)

With async and without streaming

import asyncio
import os

from mistralai import Mistral
from mistralai.models import UserMessage


async def main():
    api_key = os.environ["MISTRAL_API_KEY"]
    model = "mistral-large-latest"

    client = Mistral(api_key=api_key)

    chat_response = await client.chat.complete_async(
        model=model,
        messages=[UserMessage(content="What is the best French cheese?")],
    )

    print(chat_response.choices[0].message.content)


if __name__ == "__main__":
    asyncio.run(main())

With async and with streaming

import asyncio
import os

from mistralai import Mistral


async def main():
    api_key = os.environ["MISTRAL_API_KEY"]
    model = "mistral-large-latest"

    client = Mistral(api_key=api_key)

    response = await client.chat.stream_async(
        model=model,
        messages=[
             {
                  "role": "user",
                  "content": "Who is the best French painter? Answer in JSON.",
              },
        ],
    )
    async for chunk in response:
        if chunk.data.choices[0].delta.content is not None:
            print(chunk.data.choices[0].delta.content, end="")


if __name__ == "__main__":
    asyncio.run(main())

Chat messages
Chat messages (messages) are a collection of prompts or messages, with each message having a specific role assigned to it, such as "system," "user," "assistant," or "tool."

A system message is an optional message that sets the behavior and context for an AI assistant in a conversation, such as modifying its personality or providing specific instructions. A system message can include task instructions, personality traits, contextual information, creativity constraints, and other relevant guidelines to help the AI better understand and respond to the user's input. See the API reference for explanations on how to set up a custom system prompt.
A user message is a message sent from the perspective of the human in a conversation with an AI assistant. It typically provides a request, question, or comment that the AI assistant should respond to. User prompts allow the human to initiate and guide the conversation, and they can be used to request information, ask for help, provide feedback, or engage in other types of interaction with the AI.
An assistant message is a message sent by the AI assistant back to the user. It is usually meant to reply to a previous user message by following its instructions, but you can also find it at the beginning of a conversation, for example to greet the user.
A tool message only appears in the context of function calling, it is used at the final response formulation step when the model has to format the tool call's output for the user. To learn more about function calling, see the guide.
When to use user prompt vs. system message then user message?
You can either combine your system message and user message into a single user message or separate them into two distinct messages.
We recommend you experiment with both ways to determine which one works better for your specific use case.
Other useful features
The prefix flag enables prepending content to the assistant's response content. When used in a message, it allows the addition of an assistant's message at the end of the list, which will be prepended to the assistant's response. For more details on how it works see prefix.

The safe_prompt flag is used to force chat completion to be moderated against sensitive content (see Guardrailing).

A stop sequence allows forcing the model to stop generating after one or more chosen tokens or strings.


Vision
Vision capabilities enable models to analyze images and provide insights based on visual content in addition to text. This multimodal approach opens up new possibilities for applications that require both textual and visual understanding.

For more specific use cases regarding document parsing and data extraction we recommend taking a look at our Document AI stack here.

Models with Vision Capabilities:
Pixtral 12B (pixtral-12b-latest)
Pixtral Large 2411 (pixtral-large-latest)
Mistral Medium 2505 (mistral-medium-latest)
Mistral Small 2503 (mistral-small-latest)
Passing an Image URL
If the image is hosted online, you can simply provide the URL of the image in the request. This method is straightforward and does not require any encoding.

python
typescript
curl
import os
from mistralai import Mistral

# Retrieve the API key from environment variables
api_key = os.environ["MISTRAL_API_KEY"]

# Specify model
model = "pixtral-12b-2409"

# Initialize the Mistral client
client = Mistral(api_key=api_key)

# Define the messages for the chat
messages = [
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "What's in this image?"
            },
            {
                "type": "image_url",
                "image_url": "https://tripfixers.com/wp-content/uploads/2019/11/eiffel-tower-with-snow.jpeg"
            }
        ]
    }
]

# Get the chat response
chat_response = client.chat.complete(
    model=model,
    messages=messages
)

# Print the content of the response
print(chat_response.choices[0].message.content)


Passing a Base64 Encoded Image
If you have an image or a set of images stored locally, you can pass them to the model in base64 encoded format. Base64 encoding is a common method for converting binary data into a text format that can be easily transmitted over the internet. This is particularly useful when you need to include images in API requests.

python
typescript
curl
import base64
import requests
import os
from mistralai import Mistral

def encode_image(image_path):
    """Encode the image to base64."""
    try:
        with open(image_path, "rb") as image_file:
            return base64.b64encode(image_file.read()).decode('utf-8')
    except FileNotFoundError:
        print(f"Error: The file {image_path} was not found.")
        return None
    except Exception as e:  # Added general exception handling
        print(f"Error: {e}")
        return None

# Path to your image
image_path = "path_to_your_image.jpg"

# Getting the base64 string
base64_image = encode_image(image_path)

# Retrieve the API key from environment variables
api_key = os.environ["MISTRAL_API_KEY"]

# Specify model
model = "pixtral-12b-2409"

# Initialize the Mistral client
client = Mistral(api_key=api_key)

# Define the messages for the chat
messages = [
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "What's in this image?"
            },
            {
                "type": "image_url",
                "image_url": f"data:image/jpeg;base64,{base64_image}" 
            }
        ]
    }
]

# Get the chat response
chat_response = client.chat.complete(
    model=model,
    messages=messages
)

# Print the content of the response
print(chat_response.choices[0].message.content)

Use cases
Understand charts
Compare images
Transcribe receipts
OCR old documents
OCR with structured output
FAQ
What is the price per image?

The price is calculated using the same pricing as input tokens per image, with each image being tokenized.

How many tokens correspond to an image and/or what is the maximum resolution?

Depending on the model and resolution, an image will be tokenized differently. Below is a summary.

Model	Max Resolution	≈ Formula	≈ N Max Tokens
Mistral Small 3.2	1540x1540	≈ (ResolutionX * ResolutionY) / 784	≈ 3025
Mistral Medium 3	1540x1540	≈ (ResolutionX * ResolutionY) / 784	≈ 3025
Mistral Small 3.1	1540x1540	≈ (ResolutionX * ResolutionY) / 784	≈ 3025
Pixtral Large	1024x1024	≈ (ResolutionX * ResolutionY) / 256	≈ 4096
Pixtral 12B	1024x1024	≈ (ResolutionX * ResolutionY) / 256	≈ 4096
If the resolution of the image sent is higher than the maximum resolution of the model, the image will be downscaled to its maximum resolution. An error will be sent if the resolution is higher than 10000x10000.

Can I fine-tune the image capabilities?

Yes, you can fine-tune pixtral-12b.

Can I use them to generate images?

No, they are designed to understand and analyze images, not to generate them.

What types of image files are supported?

We currently support the following image formats:

PNG (.png)
JPEG (.jpeg and .jpg)
WEBP (.webp)
Non-animated GIF with only one frame (.gif)
Is there a limit to the size of the image?

The current file size limit is 10Mb.

What's the maximum number images per request?

The maximum number images per request via API is 8.

What is the rate limit?

For information on rate limits, please visit https://console.mistral.ai/limits/.

Audio & Transcription
Audio input capabilities enable models to chat and understand audio directly, this can be used for both chat use cases via audio or for optimal transcription purposes.

audio_graph
Models with Audio Capabilities
Audio capable models:

Voxtral Small (voxtral-small-latest) with audio input for chat use cases.
Voxtral Mini (voxtral-mini-latest) with audio input for chat use cases
And Voxtral Mini Transcribe (voxtral-mini-latest via audio/transcriptions), with an efficient transcription only service.
Chat with Audio
Our Voxtral models are capable of being used for chat use cases with our chat completions endpoint.

Passing an Audio File
To pass a local audio file, you can encode it in base64 and pass it as a string.

python
typescript
curl
curl --location https://api.mistral.ai/v1/chat/completions \
  --header "Authorization: Bearer $MISTRAL_API_KEY" \
  --header "Content-Type: application/json" \
  --data '{
    "model": "voxtral-mini-latest",
    "messages": [
      {
        "role": "user",
        "content": [
          {
            "type": "input_audio",
            "input_audio": "<audio_base64>",
          },
          {
            "type": "text",
            "text": "What'\''s in this file?"
          }
        ]
      }
    ]
  }'

Passing an Audio URL
You can also provide an url of a file.

python
typescript
curl
curl --location https://api.mistral.ai/v1/chat/completions \
  --header "Authorization: Bearer $MISTRAL_API_KEY" \
  --header "Content-Type: application/json" \
  --data '{
    "model": "voxtral-mini-2507",
    "messages": [
      {
        "role": "user",
        "content": [
          {
            "type": "input_audio",
            "input_audio": "https://download.samplelib.com/mp3/sample-15s.mp3"
          },
          {
            "type": "text",
            "text": "What'\''s in this file?"
          }
        ]
      }
    ]
  }'

Passing an Uploaded Audio File
Alternatively, you can upload a local file to our cloud and then use a signed URL for the task.

python
typescript
curl
Upload the Audio File

curl --location https://api.mistral.ai/v1/files \
  --header "Authorization: Bearer $MISTRAL_API_KEY" \
  --form purpose="audio" \
  --form file="@local_audio.mp3"

Get the Signed URL

curl --location "https://api.mistral.ai/v1/files/$id/url?expiry=24" \
    --header "Accept: application/json" \
    --header "Authorization: Bearer $MISTRAL_API_KEY"

Send Completion Request

curl --location https://api.mistral.ai/v1/chat/completions \
  --header "Authorization: Bearer $MISTRAL_API_KEY" \
  --header "Content-Type: application/json" \
  --data '{
    "model": "voxtral-mini-2507",
    "messages": [
      {
        "role": "user",
        "content": [
          {
            "type": "input_audio",
            "input_audio": "<signed_url>"
          },
          {
            "type": "text",
            "text": "What'\''s in this file?"
          }
        ]
      }
    ]
  }'

Samples
Transcription
Transcription provides an optimized endpoint for transcription purposes and currently supports voxtral-mini-latest, which runs Voxtral Mini Transcribe.

Parameters
We provide different settings and parameters for transcription, such as:

timestamp_granularities: This allows you to set timestamps to track not only "what" was said but also "when". You can find more about timestamps here.
language: Our transcription service also works as a language detection service. However, you can manually set the language of the transcription for better accuracy if the language of the audio is already known.
Passing an Audio File
Among the different methods to pass the audio, you can directly provide a path to a file to upload and transcribe it as follows:

python
typescript
curl
curl --location 'https://api.mistral.ai/v1/audio/transcriptions' \
  --header "x-api-key: $MISTRAL_API_KEY" \
  --form 'file=@"/path/to/file/audio.mp3"' \
  --form 'model="voxtral-mini-2507"' \

With Language defined

curl --location 'https://api.mistral.ai/v1/audio/transcriptions' \
  --header "x-api-key: $MISTRAL_API_KEY" \
  --form 'file=@"/path/to/file/audio.mp3"' \
  --form 'model="voxtral-mini-2507"' \
  --form 'language="en"'

Passing an Audio URL
Similarly, you can provide an url of an audio file.

python
typescript
curl
curl --location 'https://api.mistral.ai/v1/audio/transcriptions' \
  --header "x-api-key: $MISTRAL_API_KEY" \
  --form 'file_url="https://docs.mistral.ai/audio/obama.mp3"' \
  --form 'model="voxtral-mini-2507"'

With Language defined

curl --location 'https://api.mistral.ai/v1/audio/transcriptions' \
  --header "x-api-key: $MISTRAL_API_KEY" \
  --form 'file_url="https://docs.mistral.ai/audio/obama.mp3"' \
  --form 'model="voxtral-mini-2507"' \
  --form 'language="en"'

Passing an Uploaded Audio File
Alternatively, you can first upload the file to our cloud service and then pass the signed URL instead.

python
typescript
curl
Upload the Audio File

curl --location https://api.mistral.ai/v1/files \
  --header "Authorization: Bearer $MISTRAL_API_KEY" \
  --form purpose="audio" \
  --form file="@local_audio.mp3"

Get the Signed URL

curl --location "https://api.mistral.ai/v1/files/$id/url?expiry=24" \
    --header "Accept: application/json" \
    --header "Authorization: Bearer $MISTRAL_API_KEY"

Send Transcription Request

curl --location 'https://api.mistral.ai/v1/audio/transcriptions' \
    --header "x-api-key: $MISTRAL_API_KEY" \
    --form 'file_url="<signed_url>"' \
    --form 'model="voxtral-mini-2507"'

Send Transcription Request with Language defined

curl --location 'https://api.mistral.ai/v1/audio/transcriptions' \
    --header "x-api-key: $MISTRAL_API_KEY" \
    --form 'file_url="<signed_url>"' \
    --form 'model="voxtral-mini-2507"' \
    --form 'language="en"'

JSON Output
Samples
Transcription with Timestamps
You can request timestamps for the transcription by passing the timestamp_granularities parameter, currently supporting segment.
It will return the start and end time of each segment in the audio file.

python
typescript
curl
curl --location 'https://api.mistral.ai/v1/audio/transcriptions' \
--header "x-api-key: $MISTRAL_API_KEY" \
--form 'file_url="https://docs.mistral.ai/audio/obama.mp3"' \
--form 'model="voxtral-mini-latest"'
--form 'timestamp_granularities="segment"'

JSON Output
FAQ
What's the maximum audio length?

The maximum length will depend on the endpoint used, currently the limits are as follows:

≈20 minutes for Chat with Audio for both models.
≈15 minutes for Transcription, longer transcriptions will be available soon.
tip
Here are some tips if you need to handle longer audio files:

Divide the audio into smaller segments: Transcribe each segment individually. However, be aware that this might lead to a loss of context, difficulties in splitting the audio at natural pauses (such as mid-sentence), and the need to combine the transcriptions afterward.
Increase the playback speed: Send the file at a faster pace by speeding up the audio. Keep in mind that this can reduce audio quality and require adjusting the transcription timestamps to align with the original audio file.
Reasoning
Reasoning is the next step of CoT (Chain of Thought), naturally used to describe the logical steps generated by the model before reaching a conclusion. Reasoning strengthens this characteristic by going through training steps that encourage the model to generate chains of thought freely before producing the final answer. This allows models to explore the problem more profoundly and ultimately reach a better solution to the best of their ability by using extra compute time to generate more tokens and improve the answer—also described as Test Time Computation.

reasoning_graph
They excel at complex use cases like math and coding tasks, but can be used in a wide range of scenarios to solve diverse problems.

The output of reasoning models will hence be split into 2 sections, the reasoning chunks, where you can find the reasoning traces the model generated, and the final answer outside of the thinking chunks.

Currently we have two reasoning models:

magistral-small-latest: Our open smaller version for open research and efficient reasoning.
magistral-medium-latest: Our more powerful reasoning model balancing performance and cost.
info
Currently, -latest points to -2507, our most recent version of our reasoning models. If you were previously using -2506, a migration regarding the thinking chunks is required.

-2507 (new): Uses tokenized thinking chunks via control tokens, providing the thinking traces in different types of content chunks.
-2506 (old): Used <think>\n and \n</think>\n tags as strings to encapsulate the thinking traces for input and output within the same content type.
2507 (new)
2506 (old)
[
  {
    "role": "system",
    "content": [
      {
        "type": "text",
        "text": "System prompt, with both instructions and"
      },
      {
        "type": "thinking",
        "thinking": [
          {
            "type": "text",
            "text": "Encapsulated reasoning instructions."
          }
        ]
      }
    ]
  },
  {
    "role": "user",
    "content": [
      {
        "type": "text",
        "text": "User input."
      }
    ]
  },
  {
    "role": "assistant",
    "content": [
      {
        "type": "thinking",
        "thinking": [
          {
            "type": "text",
            "text": "Reasoning traces."
          }
        ]
      },
      {
        "type": "text",
        "text": "Followed by the final answer."
      }
    ]
  }
]

System Prompt
To have the best performance out of our models, we recommend having the following system prompt (currently default):

System Prompt
You can also opt out of the default system prompt by setting prompt_mode to null in the API. The prompt_mode has two possible values:

reasoning: the default behavior where the default system prompt will be used explicitly.
null: no system prompt will be used whatsoever.
Providing your own system prompt will override the default system prompt with the new one.

Usage
You can use our reasoning models in a similar way to how you would use our other text models, here is an example via our chat completions endpoint:

python
typescript
curl
import os
from mistralai import Mistral

api_key = os.environ["MISTRAL_API_KEY"]
model = "magistral-medium-latest"

client = Mistral(api_key=api_key)

chat_response = client.chat.complete(
    model = model,
    messages = [
        {
            "role": "user",
            "content": "John is one of 4 children. The first sister is 4 years old. Next year, the second sister will be twice as old as the first sister. The third sister is two years older than the second sister. The third sister is half the age of her older brother. How old is John?",
        },
    ],
    # prompt_mode = "reasoning" if you want to explicitly use the default system prompt, or None if you want to opt out of the default system prompt.
)

print(chat_response.choices[0].message.content)

2507 (new)
2506 (old)
The output of the model will include different chunks of content, but mostly a thinking type with the reasoning traces and a text type with the answer like so:

"content": [
  {
    "type": "thinking",
    "thinking": [
      {
        "type": "text",
        "text": "*Thoughts and reasoning traces will go here.*"
      }
    ]
  },
  {
    "type": "text",
    "text": "*Final answer will go here.*"
  },
  ...
]

{
  "model": "magistral-medium-2507",
  "usage": {
    "prompt_tokens": 173,
    "total_tokens": 11170,
    "completion_tokens": 10997
  },
  "object": "chat.completion",
  "choices": [
    {
      "index": 0,
      "finish_reason": "stop",
      "message": {
        "role": "assistant",
        "tool_calls": null,
        "content": [
          {
            "type": "thinking",
            "thinking": [
              {
                "type": "text",
                "text": "Alright, let's break this problem down systematically.\n\n1. Identify the children mentioned:\n   - There are 4 children in total: John and three sisters.\n\n2. Information about the sisters:\n   - First sister: 4 years old.\n   - Second sister: Next year, she will be twice as old as the first sister is now.\n     - Current age of first sister: 4 years.\n     - Next year, the first sister will be 5 years old.\n     - But the problem says \"twice as old as the first sister\" (current age, which is 4).\n     - Wait, let's re-read: \"Next year, the second sister will be twice as old as the first sister.\"\n       - Next year, the first sister will be 5 (since she's 4 now).\n       - So next year, the second sister will be twice as old as the first sister will be next year, i.e., twice 5 = 10 years old next year.\n       - Therefore, currently, the second sister is 10 - 1 = 9 years old.\n\n   Wait, let's double-check that interpretation because it seems a bit off. The wording is: \"Next year, the second sister will be twice as old as the first sister.\"\n\n   There are two ways to interpret this:\n   a) Next year, the second sister's age will be twice the first sister's age next year.\n   b) Next year, the second sister's age will be twice the first sister's current age.\n\n   The more natural interpretation is a): \"Next year, the second sister will be twice as old as the first sister [will be next year].\"\n\n   So:\n   - First sister's current age: 4\n   - Next year, first sister will be 5.\n   - Next year, second sister will be twice that, so 10.\n   - Therefore, second sister's current age is 10 - 1 = 9.\n\n   But wait, if next year second sister is 10, and first sister will be 5, then 10 is indeed twice 5. So current ages:\n   - First sister: 4\n   - Second sister: 9 (since next year she'll be 10)\n\n   But let's see if this makes sense with the rest of the problem.\n\n3. Third sister's age:\n   - The third sister is two years older than the second sister.\n   - Second sister is currently 9, so third sister is 9 + 2 = 11 years old.\n\n4. Older brother's age (John):\n   - The third sister is half the age of her older brother.\n   - Third sister is 11, so older brother is 11 * 2 = 22 years old.\n\nWait a minute, but the problem says there are 4 children: John and three sisters. So John is one of the four, and the other three are sisters. So if John is the older brother, then the four children are:\n1. First sister: 4\n2. Second sister: 9\n3. Third sister: 11\n4. John: ?\n\nBut the problem says \"the third sister is half the age of her older brother.\" So John is the older brother, meaning he's older than the third sister (11). So if third sister is half his age, then John is 22.\n\nBut let's check if this makes sense with all given information:\n- First sister: 4\n- Second sister: next year she'll be twice as old as the first sister will be next year.\n   - Next year, first sister: 5\n   - So second sister next year: 10, so now she's 9.\n- Third sister is two years older than second sister: 9 + 2 = 11.\n- Third sister is half as old as her older brother (John): so John is 22.\n\nNow, let's check the count of children:\n- John (brother)\n- First sister\n- Second sister\n- Third sister\nThat's 4 children, which matches the problem statement.\n\nBut wait, the problem says \"John is one of 4 children.\" So the four children are:\n1. John\n2. First sister\n3. Second sister\n4. Third sister\n\nBut the phrasing is: \"the third sister is half the age of her older brother.\" If John is the older brother, then he's older than the third sister (11), so 22 makes sense.\n\nBut let me think if there's another way to interpret it. Could \"her older brother\" refer to someone else? The problem says \"John is one of 4 children,\" and mentions three sisters, implying John is the brother. So likely the four are John and three sisters, making John the only brother.\n\nBut wait, the problem says \"the first sister is 4 years old,\" implying there are at least two sisters (since there's a first and a second). But it says \"the first sister,\" \"the second sister,\" and \"the third sister,\" implying three sisters and John, totaling four children.\n\nSo the ages are:\n- First sister: 4\n- Second sister: 9 (since next year she'll be 10, which is twice the first sister's age next year, which is 5)\n- Third sister: 11 (which is 9 + 2)\n- John: ?\n\nThe third sister is half the age of her older brother. So if the older brother is John, then John is 22.\n\nBut let's see if there's another possibility. Could there be another brother? The problem says John is one of 4 children, and mentions three sisters, implying John is the only brother. So likely John is the older brother referred to.\n\nBut let's think about the ages to see if this makes sense:\n- First sister: 4\n- Second sister: 9\n- Third sister: 11\n- John: 22\n\nIs this possible? Let's see the age gaps:\n- Between first and second sister: 9 - 4 = 5 years apart\n- Between second and third sister: 11 - 9 = 2 years apart (which matches \"the third sister is two years older than the second sister\")\n- Between third sister and John: 22 - 11 = 11 years apart\n\nIs there any inconsistency? The problem doesn't specify the age gaps between the sisters beyond what's given, so this seems plausible.\n\nBut let me think if there's another way to parse the problem. Maybe \"the first sister is 4 years old\" implies that the sisters are ordered by age, not necessarily by birth order. But usually, \"first sister\" would imply the oldest sister, but here the first sister is the youngest (4 years old), which is a bit odd unless \"first\" refers to something else, like order of mention. But likely it's by age, with first sister being the youngest.\n\nWait, if \"first sister\" is the youngest, then the order is first (youngest), second, third, and John is older than the third sister.\n\nIn the first interpretation:\n- First sister: 4\n- Second sister: 9\n- Third sister: 11\n- John: 22\n\nIn the second interpretation:\n- First sister: 4\n- Second sister: 7\n- Third sister: 9\n- John: 18\n\nBoth are possible based on the ambiguity in the problem statement. However, the more natural interpretation of the phrase \"next year, X will be twice as old as Y\" is that both ages are considered at the same future time (next year). So the first interpretation is more likely correct, making John 22.\n\nBut let me think if there's a way to confirm. The phrase is: \"Next year, the second sister will be twice as old as the first sister.\"\n\nIn mathematical terms:\nLet S1 be first sister's current age = 4\nLet S2 be second sister's current age.\nThen: S2 + 1 = 2 * (S1 + 1)\nS2 + 1 = 2 * (4 + 1) = 2 * 5 = 10\nSo S2 = 9.\n\nThen third sister is S3 = S2 + 2 = 11.\nAnd John's age J is such that S3 = J / 2 → J = 2 * S3 = 22.\n\nSo John is 22 years old.\n\nBut let me think if the ordering makes sense. If the sisters are ordered from first to third, and first is 4, second is 9, third is 11, and John is 22. That seems plausible, with John being the oldest.\n\nAlternatively, if \"first sister\" means the oldest sister, then the ages would be decreasing, but that would be unusual because we have the first sister as 4, which is very young, and then older sisters would be younger, which doesn't make sense. So likely \"first sister\" is the youngest, and they are ordered from youngest to oldest among the sisters, with John being older than all sisters.\n\nThus, John is 22 years old.\n\nBut wait, let's think about the numbering of sisters. Typically, \"first sister\" would refer to the firstborn sister, i.e., the oldest sister. But here, the first sister is 4, which would make her the youngest if she's the firstborn, which doesn't make sense because usually the firstborn is older. Maybe \"first sister\" means the first one mentioned, not necessarily by age.\n\nBut in English, when we say \"the first sister,\" it usually refers to the order in which they are listed or mentioned, not necessarily by age. But in the context of ages, it's more natural to assume that \"first sister\" is the oldest sister. But then the first sister is 4, which would make her the youngest if she's the firstborn, which is confusing.\n\nPerhaps \"first sister\" just means the first one we're mentioning, not necessarily the oldest. Similarly for second and third sisters. Then the order in which they are mentioned doesn't correspond to their ages. Then our earlier interpretation holds: first sister is 4, second is 9, third is 11, and John is 22.\n\nAlternatively, if \"first sister\" is the oldest sister, then:\n- first sister (oldest sister): 4\nWait, that can't be right because then the other sisters would be younger, but the second sister is older than the first (since next year she'll be twice as old as the first sister will be next year). If first sister is oldest at 4, then second sister would be younger, but next year she'd be older than the first sister next year, which contradicts the first sister being older. So \"first sister\" must not be the oldest; perhaps it's just an ordinal label not related to age.\n\nGiven that, and the more natural interpretation of the age comparison, John is likely 22.\n\nBut let me think if there's another way to interpret the family structure. The problem says John is one of 4 children. The other three are sisters. So the four children are: John, sister1, sister2, sister3.\n\nThe wording is: \"the first sister is 4 years old. Next year, the second sister will be twice as old as the first sister. The third sister is two years older than the second sister. The third sister is half the age of her older brother.\"\n\nSo the four children are:\n1. John (brother)\n2. First sister: 4\n3. Second sister: ?\n4. Third sister: ?\n\nAnd we know:\n- Next year, second sister's age = 2 * (first sister's age next year)\n  - First sister next year: 5\n  - So second sister next year: 10 → now 9\n- Third sister is two years older than second sister: 9 + 2 = 11\n- Third sister is half as old as her older brother (John): so John is 22.\n\nThis seems correct.\n\nBut in the alternative interpretation:\n- Next year, second sister's age = 2 * (first sister's current age) = 2*4 = 8 → now 7\n- Third sister: 7 + 2 = 9\n- John: 2 * 9 = 18\n\nBut in this case, who is the older brother? The third sister is 9, and John is 18, which fits (she is half his age). But then the sisters are 4, 7, and 9, and John is 18. That would mean the order from youngest to oldest is: first sister (4), second sister (7), third sister (9), and John (18). That seems plausible in terms of age gaps.\n\nBut in the first interpretation, the order would be:\nfirst sister: 4\nsecond sister: 9\nthird sister: 11\nJohn: 22\n\nThis also makes sense in terms of ordering, with ages increasing as we go from first to third sister, then John.\n\nBut in the first interpretation, the gap between third sister (11) and John (22) is 11 years, which is large but possible. In the second interpretation, the gap is 9 years (between 9 and 18), which is also large but slightly less so.\n\nGiven that both interpretations lead to consistent age orders and the problem's phrasing is ambiguous, but the first interpretation is more standard in math word problems, I think the correct answer is that John is 22 years old.\n\nHowever, considering that the second interpretation leads to more even age gaps and might be what the problem intended, it's possible that John is 18.\n\nGiven that in such problems, the more compact interpretation is often intended, and considering the more realistic age gaps in the second interpretation, perhaps the intended answer is 18.\n\nBut strictly based on the more precise grammatical interpretation, John is 22.\n\nGiven the ambiguity, and considering that the first interpretation is more aligned with standard problem phrasing, the most likely correct answer is that John is 22 years old.\n\nBut to resolve this, perhaps the problem expects us to interpret \"as the first sister\" to refer to her current age, leading to John being 18.\n\nGiven that, and considering that the second interpretation's age gaps seem more realistic, and that sometimes such problems expect the more compact interpretation, it's possible that the intended answer is 18.\n\nHowever, based on precise interpretation of the phrase, John is 22.\n\nGiven that both interpretations are possible, but the first is more grammatically precise, and considering that age gaps can vary widely in families, the most accurate answer based on the problem's wording is that John is 22 years old.\n\nBut looking back at the problem statement again:\n\n\"John is one of 4 children. The first sister is 4 years old. Next year, the second sister will be twice as old as the first sister. The third sister is two years older than the second sister. The third sister is half the age of her older brother. How old is John?\"\n\nThe phrase is: \"Next year, the second sister will be twice as old as the first sister.\"\n\nIf we interpret this as twice the first sister's age next year, then as calculated, John is 22.\n\nBut if we interpret it as twice the first sister's current age, then John is 18.\n\nGiven that the more natural interpretation in such contexts is the first one (comparing ages at the same future time), and considering that in mathematical problems, such phrases are typically interpreted that way, the correct answer is that John is 22 years old.\n\nBut let me see if there's a way to confirm. Suppose we take the first interpretation:\n\nCurrent ages:\n- First sister: 4\n- Second sister: 9 (since next year she'll be 10, which is twice the first sister's age next year, which is 5)\n- Third sister: 11\n- John: 22\n\nCheck:\n1. First sister is 4: correct.\n2. Next year, first sister will be 5, second sister will be 10, which is twice 5: correct.\n3. Third sister is 11, which is 2 more than second sister's 9: correct.\n4. Third sister (11) is half of John's age (22): correct.\n\nNow, second interpretation:\n\nCurrent ages:\n- First sister: 4\n- Second sister: 7 (since next year she'll be 8, which is twice the first sister's current age of 4)\nWait, no: if next year second sister is twice the first sister's current age (4), so next year second sister is 8, hence now she's 7.\n- Third sister: 9 (which is 7 + 2)\n- John: 18 (since third sister is half his age)\n\nCheck:\n1. First sister is 4: correct.\n2. Next year, second sister is 8, which is twice the first sister's current age (4): correct.\n3. Third sister is 9, which is 2 more than second sister's 7: correct.\n4. Third sister (9) is half of John's age (18): correct.\n\nBoth interpretations satisfy all given conditions. Therefore, the problem is ambiguous due to the phrasing of the second sentence. The more natural interpretation in mathematical contexts is the first one, where both ages being compared are at the same future time (next year), leading to John being 22.\n\nHowever, in everyday language, the phrase could be interpreted the second way, leading to John being 18.\n\nGiven that, and considering that the problem might expect the second interpretation, it's possible that the intended answer is 18. But based on precise interpretation, John is 22.\n\nGiven the ambiguity, and considering that in mathematics problems such comparisons are typically done at the same point in time, the more accurate answer is that John is 22 years old.\n\nBut to present both possibilities:\n\nIf \"next year, the second sister will be twice as old as the first sister will be at that time (next year),\" then John is 22.\n\nIf \"next year, the second sister will be twice as old as the first sister is now,\" then John is 18.\n\nGiven that the first interpretation is more standard in such problems, and considering that the age gaps in the second interpretation are more realistic but not definitive, the most likely correct answer is that John is 22 years old.\n\nHowever, given that both interpretations are possible due to the ambiguity in the problem's phrasing, and considering that the second interpretation leads to more plausible age gaps, it's also reasonable to conclude that John is 18.\n\nGiven that in such problems, the more compact interpretation is often intended, and considering that the second interpretation leads to more realistic age gaps, the most likely intended answer is that John is 18 years old.\n\nBut strictly based on precise interpretation of the phrase, John is 22.\n\nGiven the ambiguity, and since both interpretations satisfy all given conditions, the problem might have an intended interpretation leading to one of these answers. Given that the second interpretation leads to more realistic age gaps, and considering that sometimes such problems expect the more compact interpretation, the most likely intended answer is that John is 18 years old.\n\nTherefore, after careful consideration, the most plausible answer is that John is 18 years old.\n\nBut based on precise interpretation of the phrase, John is 22. Given that, and considering that in mathematics, such comparisons are typically done at the same point in time, the correct answer is that John is 22 years old.\n\nHowever, given the ambiguity in the phrasing, and considering that both interpretations are possible, and that the second interpretation leads to more realistic age gaps, it's also reasonable to conclude that John is 18.\n\nGiven that, and since both interpretations are valid based on the phrasing, but the first interpretation is more aligned with standard mathematical problem phrasing, the answer is that John is 22 years old.\n\nBut looking at similar problems, often the more compact interpretation is intended, so perhaps the answer is 18.\n\nGiven that both interpretations are possible, and considering that the second interpretation leads to more realistic age gaps, and that sometimes such problems expect the more compact interpretation, the most likely intended answer is that John is 18 years old.\n\nBut strictly based on precise interpretation, John is 22.\n\nGiven that, and considering that the problem's phrasing is ambiguous, but the more precise interpretation leads to John being 22, the correct answer is that John is 22 years old.\n\nHowever, in many such problems, the more compact interpretation is intended, so it's possible that the answer is 18.\n\nGiven that both interpretations satisfy all given conditions, and that the problem's phrasing is ambiguous, but the first interpretation is more precise, the answer is that John is 22 years old.\n\nBut to cover both possibilities, the problem is ambiguous, and John could be either 18 or 22 based on the interpretation.\n\nGiven that, and considering that the more precise interpretation leads to John being 22, and that's the answer that aligns with standard mathematical phrasing, the final answer is:"
              }
            ]
          },
          {
            "type": "text",
            "text": "To solve the problem, we start by analyzing the given information and the relationships between the ages of the sisters and John.\n\n1. The first sister is currently 4 years old.\n2. Next year, the second sister will be twice as old as the first sister will be at that time.\n3. The third sister is two years older than the second sister.\n4. The third sister is half the age of her older brother, John.\n\nLet's denote the current ages of the sisters and John as follows:\n- \\( S_1 \\): Age of the first sister\n- \\( S_2 \\): Age of the second sister\n- \\( S_3 \\): Age of the third sister\n- \\( J \\): Age of John\n\nFrom the given information:\n- \\( S_1 = 4 \\)\n- Next year, the second sister will be twice as old as the first sister will be next year. Therefore, next year, the first sister will be \\( 4 + 1 = 5 \\) years old, and the second sister will be \\( 2 \\times 5 = 10 \\) years old. This means the current age of the second sister is \\( 10 - 1 = 9 \\) years old.\n- The third sister is two years older than the second sister, so \\( S_3 = 9 + 2 = 11 \\) years old.\n- The third sister is half the age of her older brother, John. Therefore, \\( J = 2 \\times 11 = 22 \\) years old.\n\nThus, the age of John is \\(\\boxed{22}\\)."
          }
        ]
      }
    }
  ]
}


Alright, let's break this problem down systematically.

Identify the children mentioned:

There are 4 children in total: John and three sisters.
Information about the sisters:

First sister: 4 years old.
Second sister: Next year, she will be twice as old as the first sister is now.
Current age of first sister: 4 years.
Next year, the first sister will be 5 years old.
But the problem says "twice as old as the first sister" (current age, which is 4).
Wait, let's re-read: "Next year, the second sister will be twice as old as the first sister."
Next year, the first sister will be 5 (since she's 4 now).
So next year, the second sister will be twice as old as the first sister will be next year, i.e., twice 5 = 10 years old next year.
Therefore, currently, the second sister is 10 - 1 = 9 years old.
Wait, let's double-check that interpretation because it seems a bit off. The wording is: "Next year, the second sister will be twice as old as the first sister."

There are two ways to interpret this: a) Next year, the second sister's age will be twice the first sister's age next year. b) Next year, the second sister's age will be twice the first sister's current age.

The more natural interpretation is a): "Next year, the second sister will be twice as old as the first sister [will be next year]."

So:

First sister's current age: 4
Next year, first sister will be 5.
Next year, second sister will be twice that, so 10.
Therefore, second sister's current age is 10 - 1 = 9.
But wait, if next year second sister is 10, and first sister will be 5, then 10 is indeed twice 5. So current ages:

First sister: 4
Second sister: 9 (since next year she'll be 10)
But let's see if this makes sense with the rest of the problem.

Third sister's age:

The third sister is two years older than the second sister.
Second sister is currently 9, so third sister is 9 + 2 = 11 years old.
Older brother's age (John):

The third sister is half the age of her older brother.
Third sister is 11, so older brother is 11 * 2 = 22 years old.
Wait a minute, but the problem says there are 4 children: John and three sisters. So John is one of the four, and the other three are sisters. So if John is the older brother, then the four children are:

First sister: 4
Second sister: 9
Third sister: 11
John: ?
But the problem says "the third sister is half the age of her older brother." So John is the older brother, meaning he's older than the third sister (11). So if third sister is half his age, then John is 22.

But let's check if this makes sense with all given information:

First sister: 4
Second sister: next year she'll be twice as old as the first sister will be next year.
Next year, first sister: 5
So second sister next year: 10, so now she's 9.
Third sister is two years older than second sister: 9 + 2 = 11.
Third sister is half as old as her older brother (John): so John is 22.
Now, let's check the count of children:

John (brother)
First sister
Second sister
Third sister That's 4 children, which matches the problem statement.
But wait, the problem says "John is one of 4 children." So the four children are:

John
First sister
Second sister
Third sister
But the phrasing is: "the third sister is half the age of her older brother." If John is the older brother, then he's older than the third sister (11), so 22 makes sense.

But let me think if there's another way to interpret it. Could "her older brother" refer to someone else? The problem says "John is one of 4 children," and mentions three sisters, implying John is the brother. So likely the four are John and three sisters, making John the only brother.

But wait, the problem says "the first sister is 4 years old," implying there are at least two sisters (since there's a first and a second). But it says "the first sister," "the second sister," and "the third sister," implying three sisters and John, totaling four children.

So the ages are:

First sister: 4
Second sister: 9 (since next year she'll be 10, which is twice the first sister's age next year, which is 5)
Third sister: 11 (which is 9 + 2)
John: ?
The third sister is half the age of her older brother. So if the older brother is John, then John is 22.

But let's see if there's another possibility. Could there be another brother? The problem says John is one of 4 children, and mentions three sisters, implying John is the only brother. So likely John is the older brother referred to.

But let's think about the ages to see if this makes sense:

First sister: 4
Second sister: 9
Third sister: 11
John: 22
Is this possible? Let's see the age gaps:

Between first and second sister: 9 - 4 = 5 years apart
Between second and third sister: 11 - 9 = 2 years apart (which matches "the third sister is two years older than the second sister")
Between third sister and John: 22 - 11 = 11 years apart
Is there any inconsistency? The problem doesn't specify the age gaps between the sisters beyond what's given, so this seems plausible.

But let me think if there's another way to parse the problem. Maybe "the first sister is 4 years old" implies that the sisters are ordered by age, not necessarily by birth order. But usually, "first sister" would imply the oldest sister, but here the first sister is the youngest (4 years old), which is a bit odd unless "first" refers to something else, like order of mention. But likely it's by age, with first sister being the youngest.

Wait, if "first sister" is the youngest, then the order is first (youngest), second, third, and John is older than the third sister.

In the first interpretation:

First sister: 4
Second sister: 9
Third sister: 11
John: 22
In the second interpretation:

First sister: 4
Second sister: 7
Third sister: 9
John: 18
Both are possible based on the ambiguity in the problem statement. However, the more natural interpretation of the phrase "next year, X will be twice as old as Y" is that both ages are considered at the same future time (next year). So the first interpretation is more likely correct, making John 22.

But let me think if there's a way to confirm. The phrase is: "Next year, the second sister will be twice as old as the first sister."

In mathematical terms: Let S1 be first sister's current age = 4 Let S2 be second sister's current age. Then: S2 + 1 = 2 * (S1 + 1) S2 + 1 = 2 * (4 + 1) = 2 * 5 = 10 So S2 = 9.

Then third sister is S3 = S2 + 2 = 11. And John's age J is such that S3 = J / 2 → J = 2 * S3 = 22.

So John is 22 years old.

But let me think if the ordering makes sense. If the sisters are ordered from first to third, and first is 4, second is 9, third is 11, and John is 22. That seems plausible, with John being the oldest.

Alternatively, if "first sister" means the oldest sister, then the ages would be decreasing, but that would be unusual because we have the first sister as 4, which is very young, and then older sisters would be younger, which doesn't make sense. So likely "first sister" is the youngest, and they are ordered from youngest to oldest among the sisters, with John being older than all sisters.

Thus, John is 22 years old.

But wait, let's think about the numbering of sisters. Typically, "first sister" would refer to the firstborn sister, i.e., the oldest sister. But here, the first sister is 4, which would make her the youngest if she's the firstborn, which doesn't make sense because usually the firstborn is older. Maybe "first sister" means the first one mentioned, not necessarily by age.

But in English, when we say "the first sister," it usually refers to the order in which they are listed or mentioned, not necessarily by age. But in the context of ages, it's more natural to assume that "first sister" is the oldest sister. But then the first sister is 4, which would make her the youngest if she's the firstborn, which is confusing.

Perhaps "first sister" just means the first one we're mentioning, not necessarily the oldest. Similarly for second and third sisters. Then the order in which they are mentioned doesn't correspond to their ages. Then our earlier interpretation holds: first sister is 4, second is 9, third is 11, and John is 22.

Alternatively, if "first sister" is the oldest sister, then:

first sister (oldest sister): 4 Wait, that can't be right because then the other sisters would be younger, but the second sister is older than the first (since next year she'll be twice as old as the first sister will be next year). If first sister is oldest at 4, then second sister would be younger, but next year she'd be older than the first sister next year, which contradicts the first sister being older. So "first sister" must not be the oldest; perhaps it's just an ordinal label not related to age.
Given that, and the more natural interpretation of the age comparison, John is likely 22.

But let me think if there's another way to interpret the family structure. The problem says John is one of 4 children. The other three are sisters. So the four children are: John, sister1, sister2, sister3.

The wording is: "the first sister is 4 years old. Next year, the second sister will be twice as old as the first sister. The third sister is two years older than the second sister. The third sister is half the age of her older brother."

So the four children are:

John (brother)
First sister: 4
Second sister: ?
Third sister: ?
And we know:

Next year, second sister's age = 2 * (first sister's age next year)
First sister next year: 5
So second sister next year: 10 → now 9
Third sister is two years older than second sister: 9 + 2 = 11
Third sister is half as old as her older brother (John): so John is 22.
This seems correct.

But in the alternative interpretation:

Next year, second sister's age = 2 * (first sister's current age) = 2*4 = 8 → now 7
Third sister: 7 + 2 = 9
John: 2 * 9 = 18
But in this case, who is the older brother? The third sister is 9, and John is 18, which fits (she is half his age). But then the sisters are 4, 7, and 9, and John is 18. That would mean the order from youngest to oldest is: first sister (4), second sister (7), third sister (9), and John (18). That seems plausible in terms of age gaps.

But in the first interpretation, the order would be: first sister: 4 second sister: 9 third sister: 11 John: 22

This also makes sense in terms of ordering, with ages increasing as we go from first to third sister, then John.

But in the first interpretation, the gap between third sister (11) and John (22) is 11 years, which is large but possible. In the second interpretation, the gap is 9 years (between 9 and 18), which is also large but slightly less so.

Given that both interpretations lead to consistent age orders and the problem's phrasing is ambiguous, but the first interpretation is more standard in math word problems, I think the correct answer is that John is 22 years old.

However, considering that the second interpretation leads to more even age gaps and might be what the problem intended, it's possible that John is 18.

Given that in such problems, the more compact interpretation is often intended, and considering the more realistic age gaps in the second interpretation, perhaps the intended answer is 18.

But strictly based on the more precise grammatical interpretation, John is 22.

Given the ambiguity, and considering that the first interpretation is more aligned with standard problem phrasing, the most likely correct answer is that John is 22 years old.

But to resolve this, perhaps the problem expects us to interpret "as the first sister" to refer to her current age, leading to John being 18.

Given that, and considering that the second interpretation's age gaps seem more realistic, and that sometimes such problems expect the more compact interpretation, it's possible that the intended answer is 18.

However, based on precise interpretation of the phrase, John is 22.

Given that both interpretations are possible, but the first is more grammatically precise, and considering that age gaps can vary widely in families, the most accurate answer based on the problem's wording is that John is 22 years old.

But looking back at the problem statement again:

"John is one of 4 children. The first sister is 4 years old. Next year, the second sister will be twice as old as the first sister. The third sister is two years older than the second sister. The third sister is half the age of her older brother. How old is John?"

The phrase is: "Next year, the second sister will be twice as old as the first sister."

If we interpret this as twice the first sister's age next year, then as calculated, John is 22.

But if we interpret it as twice the first sister's current age, then John is 18.

Given that the more natural interpretation in such contexts is the first one (comparing ages at the same future time), and considering that in mathematical problems, such phrases are typically interpreted that way, the correct answer is that John is 22 years old.

But let me see if there's a way to confirm. Suppose we take the first interpretation:

Current ages:

First sister: 4
Second sister: 9 (since next year she'll be 10, which is twice the first sister's age next year, which is 5)
Third sister: 11
John: 22
Check:

First sister is 4: correct.
Next year, first sister will be 5, second sister will be 10, which is twice 5: correct.
Third sister is 11, which is 2 more than second sister's 9: correct.
Third sister (11) is half of John's age (22): correct.
Now, second interpretation:

Current ages:

First sister: 4
Second sister: 7 (since next year she'll be 8, which is twice the first sister's current age of 4) Wait, no: if next year second sister is twice the first sister's current age (4), so next year second sister is 8, hence now she's 7.
Third sister: 9 (which is 7 + 2)
John: 18 (since third sister is half his age)
Check:

First sister is 4: correct.
Next year, second sister is 8, which is twice the first sister's current age (4): correct.
Third sister is 9, which is 2 more than second sister's 7: correct.
Third sister (9) is half of John's age (18): correct.
Both interpretations satisfy all given conditions. Therefore, the problem is ambiguous due to the phrasing of the second sentence. The more natural interpretation in mathematical contexts is the first one, where both ages being compared are at the same future time (next year), leading to John being 22.

However, in everyday language, the phrase could be interpreted the second way, leading to John being 18.

Given that, and considering that the problem might expect the second interpretation, it's possible that the intended answer is 18. But based on precise interpretation, John is 22.

Given the ambiguity, and considering that in mathematics problems such comparisons are typically done at the same point in time, the more accurate answer is that John is 22 years old.

But to present both possibilities:

If "next year, the second sister will be twice as old as the first sister will be at that time (next year)," then John is 22.

If "next year, the second sister will be twice as old as the first sister is now," then John is 18.

Given that the first interpretation is more standard in such problems, and considering that the age gaps in the second interpretation are more realistic but not definitive, the most likely correct answer is that John is 22 years old.

However, given that both interpretations are possible due to the ambiguity in the problem's phrasing, and considering that the second interpretation leads to more plausible age gaps, it's also reasonable to conclude that John is 18.

Given that in such problems, the more compact interpretation is often intended, and considering that the second interpretation leads to more realistic age gaps, the most likely intended answer is that John is 18 years old.

But strictly based on precise interpretation of the phrase, John is 22.

Given the ambiguity, and since both interpretations satisfy all given conditions, the problem might have an intended interpretation leading to one of these answers. Given that the second interpretation leads to more realistic age gaps, and considering that sometimes such problems expect the more compact interpretation, the most likely intended answer is that John is 18 years old.

Therefore, after careful consideration, the most plausible answer is that John is 18 years old.

But based on precise interpretation of the phrase, John is 22. Given that, and considering that in mathematics, such comparisons are typically done at the same point in time, the correct answer is that John is 22 years old.

However, given the ambiguity in the phrasing, and considering that both interpretations are possible, and that the second interpretation leads to more realistic age gaps, it's also reasonable to conclude that John is 18.

Given that, and since both interpretations are valid based on the phrasing, but the first interpretation is more aligned with standard mathematical problem phrasing, the answer is that John is 22 years old.

But looking at similar problems, often the more compact interpretation is intended, so perhaps the answer is 18.

Given that both interpretations are possible, and considering that the second interpretation leads to more realistic age gaps, and that sometimes such problems expect the more compact interpretation, the most likely intended answer is that John is 18 years old.

But strictly based on precise interpretation, John is 22.

Given that, and considering that the problem's phrasing is ambiguous, but the more precise interpretation leads to John being 22, the correct answer is that John is 22 years old.

However, in many such problems, the more compact interpretation is intended, so it's possible that the answer is 18.

Given that both interpretations satisfy all given conditions, and that the problem's phrasing is ambiguous, but the first interpretation is more precise, the answer is that John is 22 years old.

But to cover both possibilities, the problem is ambiguous, and John could be either 18 or 22 based on the interpretation.

Given that, and considering that the more precise interpretation leads to John being 22, and that's the answer that aligns with standard mathematical phrasing, the final answer is:

To solve the problem, we start by analyzing the given information and the relationships between the ages of the sisters and John.

The first sister is currently 4 years old.
Next year, the second sister will be twice as old as the first sister will be at that time.
The third sister is two years older than the second sister.
The third sister is half the age of her older brother, John.
Let's denote the current ages of the sisters and John as follows:

( S_1 ): Age of the first sister
( S_2 ): Age of the second sister
( S_3 ): Age of the third sister
( J ): Age of John
From the given information:

( S_1 = 4 )
Next year, the second sister will be twice as old as the first sister will be next year. Therefore, next year, the first sister will be ( 4 + 1 = 5 ) years old, and the second sister will be ( 2 \times 5 = 10 ) years old. This means the current age of the second sister is ( 10 - 1 = 9 ) years old.
The third sister is two years older than the second sister, so ( S_3 = 9 + 2 = 11 ) years old.
The third sister is half the age of her older brother, John. Therefore, ( J = 2 \times 11 = 22 ) years old.
Thus, the age of John is (\boxed22).


Mistral Document AI
Document AI Graph
Mistral Document AI offers enterprise-level document processing, combining cutting-edge OCR technology with advanced structured data extraction. Experience faster processing speeds, unparalleled accuracy, and cost-effective solutions, all scalable to meet your needs. Unlock the full potential of your documents with our multilingual support, annotations and adaptable workflows for all document types, enabling you to extract, comprehend, and analyze information with ease.

Document AI Services
Using client.ocr.process as the entry point, you can access the following services from our Document AI stack:

Basic OCR: Discover our OCR model and its extensive capabilities.
Annotations: Annotate and extract data from your documents using our built-in Structured Outputs.
Document QnA: Harness the power of our models in conjunction with our OCR technology.


Skip to main content
Mistral AI Logo
Le Chat
La Plateforme
Docs
API
GitHub
Discord

Search ⌘+K

Getting Started
Introduction
Quickstart
Models

Benchmarks
Model selection
Model weights
Clients
Model customization
Developer examples
Changelog
Glossary
Capabilities
Text and Chat Completions
Vision
Audio & Transcription
Reasoning
Document AI

Basic OCR
Annotations
Document QnA
Coding
Embeddings

Function calling
Citations and References
Structured Output

Moderation
Finetuning

Batch Inference
Predicted outputs
Agents
Introduction
Agents & Conversations
Connectors

MCP
Function Calling
Handoffs
Deployment
La Plateforme

Cloud

Self-deployment

Guides
Prompting capabilities
Basic RAG
Prefix
Tokenization
Sampling
Fine-tuning
Evaluation
Observability
Other resources
How to contribute

Coding
Coding
LLMs are powerfull tools for text generation, and they also show great performance in code generation for multiple tasks, both for code completion, code generation and agentic tool use for semi-automated software development.

We provide 2 major families of llms for coding:

Codestral: Specifically trained for Code Generation and FIM.
Devstral: Specifically trained for Agentic Tool Use for Software Development.
Note that we also provide Codestral Embed, for semantic search and embedding code databases, repositories, and powering coding assistants with state-of-the-art retrieval. Learn more about it here.

Endpoints & Models
We provide 2 main endpoints:

https://api.mistral.ai/v1/fim/completions: Fill-in-the-middle, for code completion and code generation; supporting codestral-latest.
https://api.mistral.ai/v1/chat/completions: Instruction following, for coding and agentic tool use; supporting codestral-latest, devstral-small-latest and devstral-medium-latest.
FIM
With this feature, users can define the starting point of the code using a prompt, and the ending point of the code using an optional suffix and an optional stop. The FIM model will then generate the code that fits in between, making it ideal for tasks that require a specific piece of code to be generated.

tip
We also provide the min_tokens and max_tokens sampling parameters, which are particularly useful for code generation as it allows you to set the minimum and maximum number of tokens that should be produced. This is especially useful when FIM models decide to produce no tokens at all, or are overly verbose, allowing developers to enforce completions within a specific range if they are needed.

Codestral
Codestral is a cutting-edge generative model that has been specifically designed and optimized for code generation tasks, including fill-in-the-middle and code completion. Codestral was trained on 80+ programming languages, enabling it to perform well on both common and less common languages.

important
We currently offer two domains for Codestral endpoints, both providing FIM and instruct routes:

Domain	Features
codestral.mistral.ai	- Monthly subscription based, currently free to use
- Requires a new key for which a phone number is needed
api.mistral.ai	- Allows you to use your existing API key and you can pay to use Codestral
- Ideal for business use
Wondering which endpoint to use?

If you're a user, wanting to query Codestral as part of an IDE plugin, codestral.mistral.ai is recommended.
If you're building a plugin, or anything that exposes these endpoints directly to the user, and expect them to bring their own API keys, you should also target codestral.mistral.ai
For all other use cases, api.mistral.ai will be better suited
This guide uses api.mistral.ai for demonstration.

Below we present three examples:

Example 1: Fill in the middle
Originally, these models are designed to complete code in-between 2 points: a prefix (here called prompt) and a suffix, generating the code in-between.

python
curl
import os
from mistralai import Mistral

api_key = os.environ["MISTRAL_API_KEY"]
client = Mistral(api_key=api_key)

model = "codestral-latest"
prompt = "def fibonacci(n: int):"
suffix = "n = int(input('Enter a number: '))\nprint(fibonacci(n))"

response = client.fim.complete(
    model=model,
    prompt=prompt,
    suffix=suffix,
    temperature=0,
    # min_tokens=1, # Uncomment to enforce completions to at least 1 token
)

print(
    f"""
{prompt}
{response.choices[0].message.content}
{suffix}
"""
)

Example 2: Completion
However, you can also use the model for pure code completion, by only providing a prompt and no suffix.

python
curl
import os
from mistralai import Mistral

api_key = os.environ["MISTRAL_API_KEY"]
client = Mistral(api_key=api_key)

model = "codestral-latest"
prompt = "def is_odd(n): \n return n % 2 == 1 \ndef test_is_odd():"

response = client.fim.complete(model=model, prompt=prompt, temperature=0)

print(
    f"""
{prompt}
{response.choices[0].message.content}
"""
)

Example 3: Stop tokens
You can also use stop tokens to control the generation of the model when it generates specific strings.

tip
We recommend adding stop tokens for IDE autocomplete integrations to prevent the model from being too verbose.

python
curl
import os
from mistralai import Mistral

api_key = os.environ["MISTRAL_API_KEY"]
client = Mistral(api_key=api_key)

model = "codestral-latest"
prompt = "def is_odd(n): \n return n % 2 == 1 \ndef test_is_odd():"
suffix = "n = int(input('Enter a number: '))\nprint(fibonacci(n))"

response = client.fim.complete(
    model=model, prompt=prompt, suffix=suffix, temperature=0, stop=["\n\n"]
)

print(
    f"""
{prompt}
{response.choices[0].message.content}
"""
)

Instruct Following
We also provide the instruct chat endpoint of Codestral with the same model codestral-latest.
The only difference is the endpoint used; so you can leverage powerfull code completion with instruct and chat use cases.

However we also provide devstral-small-latest and devstral-medium-latest for agentic tool use for software development, this family of models is specifically trained to navigate code bases and leverage tool usage for diverse tasks.

Codestral
Here is an example of how to use the instruct endpoint of Codestral, it's perfect for specific code generation of specific snippets or code completion while following instructions; so you can better guide generation and exchange with a powerfull coding model.

python
curl
import os
from mistralai import Mistral

api_key = os.environ["MISTRAL_API_KEY"]
client = Mistral(api_key=api_key)

model = "codestral-latest"
message = [{"role": "user", "content": "Write a function for fibonacci"}]
chat_response = client.chat.complete(
    model = model,
    messages = message
)

Devstral
While Codestral is designed for code generation and FIM, Devstral is a cutting-edge generative model that has been specifically designed and optimized for agentic tool use for software development, it can leverage function calling to navigate code bases and call the right tools to perform specific tasks for semi-automated software development.

python
curl
import os
from mistralai import Mistral

api_key = os.environ["MISTRAL_API_KEY"]
client = Mistral(api_key=api_key)

model = "devstral-medium-latest"
message = [{"role": "user", "content": "Create a new file called test.py and write a function for fibonacci"}]

tools = [
    {
        "type": "function",
        "function": {
            "name": "create_file",
            "description": "Create a new file with the given name and content",
            "parameters": {
                "type": "object",
                "properties": {
                    "filename": {
                        "type": "string",
                        "description": "The name of the file to create",
                    },
                    "content": {
                        "type": "string",
                        "description": "The content to write to the file",
                    },
                },
                "required": ["filename", "content"],
            },
        },
    }
]

chat_response = client.chat.complete(
    model = model,
    messages = message,
    tools = tools
)

Integrations
Codestral Integrations
Integration with continue.dev
Integration with Tabnine
Integration with LangChain
Integration with LlamaIndex
Integration with Jupyter AI
Integration with JupyterLite
Integration with Tabby
Integration with E2B
Devstral Integrations
Integration with Open Hands
Integration with Cline
Previous
Document QnA
Next
Embeddings
Endpoints & Models
FIM
Codestral
Instruct Following
Codestral
Devstral
Integrations
Codestral Integrations
Devstral Integrations
Documentation
Documentation
Contributing
Community
Discord
X
GitHub
Copyright © 2025 Mistral AI.


Skip to main content
Mistral AI Logo
Le Chat
La Plateforme
Docs
API
GitHub
Discord

Search ⌘+K
Getting Started
Introduction
Quickstart
Models

Benchmarks
Model selection
Model weights
Clients
Model customization
Developer examples
Changelog
Glossary
Capabilities
Text and Chat Completions
Vision
Audio & Transcription
Reasoning
Document AI

Basic OCR
Annotations
Document QnA
Coding
Embeddings

Text Embeddings
Code Embeddings
Function calling
Citations and References
Structured Output

Moderation
Finetuning

Batch Inference
Predicted outputs
Agents
Introduction
Agents & Conversations
Connectors

MCP
Function Calling
Handoffs
Deployment
La Plateforme

Cloud

Self-deployment

Guides
Prompting capabilities
Basic RAG
Prefix
Tokenization
Sampling
Fine-tuning
Evaluation
Observability
Other resources
How to contribute

EmbeddingsText Embeddings
Text Embeddings
Open In Colab
Mistral Embed API
To generate text embeddings using Mistral AI's embeddings API, we can make a request to the API endpoint and specify the embedding model mistral-embed, along with providing a list of input texts. The API will then return the corresponding embeddings as numerical vectors, which can be used for further analysis or processing in NLP applications.

python
typescript
curl
import os
from mistralai import Mistral

api_key = os.environ["MISTRAL_API_KEY"]
model = "mistral-embed"

client = Mistral(api_key=api_key)

embeddings_batch_response = client.embeddings.create(
    model=model,
    inputs=["Embed this sentence.", "As well as this one."],
)

The output embeddings_batch_response is an EmbeddingResponse object with the embeddings and the token usage information.

EmbeddingResponse(
    id='eb4c2c739780415bb3af4e47580318cc', object='list', data=[
        Data(object='embedding', embedding=[-0.0165863037109375,...], index=0),
        Data(object='embedding', embedding=[-0.0234222412109375,...], index=1)],
    model='mistral-embed', usage=EmbeddingResponseUsage(prompt_tokens=15, total_tokens=15)
)

Let's take a look at the length of the first embedding:

python
typescript
curl
len(embeddings_batch_response.data[0].embedding)

It returns 1024, which means that our embedding dimension is 1024. The mistral-embed model generates embedding vectors of dimension 1024 for each text string, regardless of the text length. It's worth nothing that while higher dimensional embeddings can better capture text information and improve the performance of NLP tasks, they may require more computational resources for hosting and inference, and may result in increased latency and memory usage for storing and processing these embeddings. This trade-off between performance and computational resources should be considered when designing NLP systems that rely on text embeddings.

Distance Measures
In the realm of text embeddings, texts with similar meanings or context tend to be located in closer proximity to each other within this space, as measured by the distance between their vectors. This is due to the fact that the model has learned to group semantically related texts together during the training process.

Let's take a look at a simple example. To simplify working with text embeddings, we can wrap the embedding API in this function:

from sklearn.metrics.pairwise import euclidean_distances

def get_text_embedding(inputs):
    embeddings_batch_response = client.embeddings.create(
        model=model,
        inputs=inputs
    )
    return embeddings_batch_response.data[0].embedding

Suppose we have two sentences: one about cats and the other about books. We want to find how similar each sentence is to the reference sentence "Books are mirrors: You only see in them what you already have inside you". We can see that the distance between the reference sentence embeddings and the book sentence embeddings is smaller than the distance between the reference sentence embeddings and the cat sentence embeddings.

sentences = [
    "A home without a cat — and a well-fed, well-petted and properly revered cat — may be a perfect home, perhaps, but how can it prove title?",
    "I think books are like people, in the sense that they'll turn up in your life when you most need them"
]
embeddings = [get_text_embedding([t]) for t in sentences]

reference_sentence = "Books are mirrors: You only see in them what you already have inside you"
reference_embedding = get_text_embedding([reference_sentence])

for t, e in zip(sentences, embeddings):
    distance = euclidean_distances([e], [reference_embedding])
    print(t, distance)

Output

A home without a cat — and a well-fed, well-petted and properly revered cat — may be a perfect home, perhaps, but how can it prove title? [[0.80094257]]
I think books are like people, in the sense that they'll turn up in your life when you most need them [[0.58162089]]

In our example above, we used the Euclidean distance to measure the distance between embedding vectors (note that since Mistral AI embeddings are norm 1, cosine similarity, dot product or Euclidean distance are all equivalent).

Paraphrase detection
Another potential use case is paraphrase detection. In this simple example, we have a list of three sentences, and we would like to find out if any of the two sentences are paraphrases of each other. If the distance between two sentence embeddings is small, it suggests that the two sentences are semantically similar and could be potential paraphrases.

The result suggests that the first two sentences are semantically similar and could be potential paraphrases, whereas the third sentence is more different. This is just a super simple example. But this approach can be extended to more complex situations in real-world applications, such as detecting paraphrases in social media posts, news articles, or customer reviews.

import itertools

sentences = [
    "Have a safe happy Memorial Day weekend everyone",
    "To all our friends at Whatsit Productions Films enjoy a safe happy Memorial Day weekend",
    "Where can I find the best cheese?",
]

sentence_embeddings = [get_text_embedding([t]) for t in sentences]

sentence_embeddings_pairs = list(itertools.combinations(sentence_embeddings, 2))
sentence_pairs = list(itertools.combinations(sentences, 2))
for s, e in zip(sentence_pairs, sentence_embeddings_pairs):
    print(s, euclidean_distances([e[0]], [e[1]]))

Output

('Have a safe happy Memorial Day weekend everyone', 'To all our friends at Whatsit Productions Films enjoy a safe happy Memorial Day weekend') [[0.54326686]]
('Have a safe happy Memorial Day weekend everyone', 'Where can I find the best cheese?') [[0.92573978]]
('To all our friends at Whatsit Productions Films enjoy a safe happy Memorial Day weekend', 'Where can I find the best cheese?') [[0.9114184]]

Batch processing
The Mistral AI Embeddings API is designed to process text in batches for improved efficiency and speed. In this example, we will demonstrate this by loading the Symptom2Disease dataset from Kaggle, which contains 1200 rows with two columns: "label" and "text". The "label" column indicates the disease category, while the "text" column describes the symptoms associated with that disease.

We wrote a function get_embeddings_by_chunks that splits data into chunks and then sends each chunk to the Mistral AI Embeddings API to get the embeddings. Then we saved the embeddings as a new column in the dataframe. Note that the API will provide auto-chunking in the future, so that users don't need to manually split the data into chunks before sending it.

import pandas as pd

df = pd.read_csv(
    "https://raw.githubusercontent.com/mistralai/cookbook/main/data/Symptom2Disease.csv",
    index_col=0,
)

def get_embeddings_by_chunks(data, chunk_size):
    chunks = [data[x : x + chunk_size] for x in range(0, len(data), chunk_size)]
    embeddings_response = [
        client.embeddings.create(model=model, inputs=c) for c in chunks
    ]
    return [d.embedding for e in embeddings_response for d in e.data]

df["embeddings"] = get_embeddings_by_chunks(df["text"].tolist(), 50)
df.head()

drawing
t-SNE embeddings visualization
We mentioned previously that our embeddings have 1024 dimensions, which makes them impossible to visualize directly. Thus, in order to visualize our embeddings, we can use a dimensionality reduction technique such as t-SNE to project our embeddings into a lower-dimensional space that is easier to visualize.

In this example, we transform our embeddings to 2 dimensions and create a 2D scatter plot showing the relationships among embeddings of different diseases.

import seaborn as sns
from sklearn.manifold import TSNE
import numpy as np

tsne = TSNE(n_components=2, random_state=0).fit_transform(np.array(df['embeddings'].to_list()))
ax = sns.scatterplot(x=tsne[:, 0], y=tsne[:, 1], hue=np.array(df['label'].to_list()))
sns.move_legend(ax, 'upper left', bbox_to_anchor=(1, 1))

drawing
Comparison with fastText
We can compare it with fastText, a popular open-source embeddings model. However, when examining the t-SNE embeddings plot, we notice that fastText embeddings fail to create clear separations between data points with matching labels.

import fasttext.util

fasttext.util.download_model('en', if_exists='ignore')  # English
ft = fasttext.load_model('cc.en.300.bin')

df['fasttext_embeddings'] = df['text'].apply(lambda x: ft.get_word_vector(x).tolist())

tsne = TSNE(n_components=2, random_state=0).fit_transform(np.array(df['fasttext_embeddings'].to_list()))
ax = sns.scatterplot(x=tsne[:, 0], y=tsne[:, 1], hue=np.array(df['label'].to_list()))
sns.move_legend(ax, 'upper left', bbox_to_anchor=(1, 1))

drawing
Classification
Text embeddings can be used as input features in machine learning models, such as classification and clustering. In this example, we use a classification model to predict the disease labels from the embeddings of disease description text.

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression

# Create a train / test split
train_x, test_x, train_y, test_y = train_test_split(
    df["embeddings"], df["label"], test_size=0.2
)

# Normalize features
scaler = StandardScaler()
train_x = scaler.fit_transform(train_x.to_list())
test_x = scaler.transform(test_x.to_list())

# Train a classifier and compute the test accuracy
# For a real problem, C should be properly cross validated and the confusion matrix analyzed
clf = LogisticRegression(random_state=0, C=1.0, max_iter=500).fit(
    train_x, train_y.to_list()
)
# you can also try the sag algorithm:
# clf = LogisticRegression(random_state=0, C=1.0, max_iter=1000, solver='sag').fit(train_x, train_y)

print(f"Precision: {100*np.mean(clf.predict(test_x) == test_y.to_list()):.2f}%")

Output

Precision: 98.75%

After we trained the classifier with our embeddings data, we can try classify other text:

# Classify a single example
text = "I've been experiencing frequent headaches and vision problems."
clf.predict([get_text_embedding([text])])

Output

'Migraine'

Comparison with fastText
Additionally, let's take a look at the performance using fastText embeddings in this classification task. It appears that the classification model achieves better performance with Mistral AI Embeddings model as compared to using fastText embeddings.

# Create a train / test split
train_x, test_x, train_y, test_y = train_test_split(
    df["fasttext_embeddings"], df["label"], test_size=0.2
)

# Normalize features
scaler = StandardScaler()
train_x = scaler.fit_transform(train_x.to_list())
test_x = scaler.transform(test_x.to_list())

# Train a classifier and compute the test accuracy
# For a real problem, C should be properly cross validated and the confusion matrix analyzed
clf = LogisticRegression(random_state=0, C=1.0, max_iter=500).fit(
    train_x, train_y.to_list()
)
# you can also try the sag algorithm:
# clf = LogisticRegression(random_state=0, C=1.0, max_iter=1000, solver='sag').fit(train_x, train_y)

print(f"Precision: {100*np.mean(clf.predict(test_x) == test_y.to_list()):.2f}%")

Output

Precision: 86.25%

Clustering
What if we don't have disease labels? One approach to gain insights from the data is through clustering. Clustering is an unsupervised machine learning technique that groups similar data points together based on their similarity with respect to certain features. In the context of text embeddings, we can use the distance between each embedding as a measure of similarity, and group together data points with embeddings that are close to each other in the high-dimensional space.

Since we already know there are 24 clusters, let's use the K-means clustering with 24 clusters. Then we can inspect a few examples and verify whether the examples in a single cluster are similar to one another. For example, take a look at the first three rows of cluster 23. We can see that they look very similar in terms of symptoms.

from sklearn.cluster import KMeans

model = KMeans(n_clusters=24, max_iter=1000)
model.fit(df['embeddings'].to_list())
df["cluster"] = model.labels_
print(*df[df.cluster==23].text.head(3), sep='\n\n')

Output:

I have been feeling extremely tired and weak, and I've also been coughing a lot with difficulty breathing. My fever is very high, and I'm producing a lot of mucus when I cough.
I've got a cough that won't go away, and I'm exhausted. I've been coughing up thick mucous and my fever is also pretty high.
I have a persistent cough and have been feeling quite fatigued. My fever is through the roof, and I'm having trouble breathing. When I cough, I also cough up a lot of mucous.

Retrieval
Our embedding model excels in retrieval tasks, as it is trained with retrieval in mind. Embeddings are also incredibly helpful in implementing retrieval-augmented generation (RAG) systems, which use retrieved relevant information from a knowledge base to generate responses. At a high-level, we embed a knowledge base, whether it is a local directory, text files, or internal wikis, into text embeddings and store them in a vector database. Then, based on the user's query, we retrieve the most similar embeddings, which represent the relevant information from the knowledge base. Finally, we feed these relevant embeddings to a large language model to generate a response that is tailored to the user's query and context. If you are interested in learning more about how RAG systems work and how to implement a basic RAG, check out our previous guide on this topic.

Previous
Embeddings
Next
Code Embeddings
Mistral Embed API
Distance Measures
Paraphrase detection
Batch processing
t-SNE embeddings visualization
Comparison with fastText
Classification
Comparison with fastText
Clustering
Retrieval
Documentation
Documentation
Contributing
Community
Discord
X
GitHub
Copyright © 2025 Mistral AI.

Skip to main content
Mistral AI Logo
Le Chat
La Plateforme
Docs
API
GitHub
Discord

Search ⌘+K
Getting Started
Introduction
Quickstart
Models

Benchmarks
Model selection
Model weights
Clients
Model customization
Developer examples
Changelog
Glossary
Capabilities
Text and Chat Completions
Vision
Audio & Transcription
Reasoning
Document AI

Basic OCR
Annotations
Document QnA
Coding
Embeddings

Text Embeddings
Code Embeddings
Function calling
Citations and References
Structured Output

Moderation
Finetuning

Batch Inference
Predicted outputs
Agents
Introduction
Agents & Conversations
Connectors

MCP
Function Calling
Handoffs
Deployment
La Plateforme

Cloud

Self-deployment

Guides
Prompting capabilities
Basic RAG
Prefix
Tokenization
Sampling
Fine-tuning
Evaluation
Observability
Other resources
How to contribute

EmbeddingsCode Embeddings
Code Embeddings
Embeddings are at the core of multiple enterprise use cases, such as retrieval systems, clustering, code analytics, classification, and a variety of search applications. With code embedings, you can embed code databases and repositories, and power coding assistants with state-of-the-art retrieval capabilities.

Open In Colab
Codestral Embed API
To generate code embeddings using Mistral AI's embeddings API, we can make a request to the API endpoint and specify the embedding model codestral-embed, along with providing a list of input texts. The API will then return the corresponding embeddings as numerical vectors, which can be used for further analysis or processing in NLP applications.

We also provide output_dtype and output_dimension parameters that allow you to control the type and dimensional size of your embeddings.

Output DType
output_dtype allows you to select the precision and format of the embeddings, enabling you to obtain embeddings with your desired level of numerical accuracy and representation.

The accepted dtypes are:

float (default): A list of 32-bit (4-byte) single-precision floating-point numbers. Provides the highest precision and retrieval accuracy.
int8: A list of 8-bit (1-byte) integers ranging from -128 to 127.
uint8: A list of 8-bit (1-byte) integers ranging from 0 to 255.
binary: A list of 8-bit integers that represent bit-packed, quantized single-bit embedding values using the int8 type. The length of the returned list of integers is 1/8 of output_dimension. This type uses the offset binary method.
ubinary: Similar to binary, but uses the uint8 type for bit-packed, quantized single-bit embedding values.
Output Dimension
output_dimension allows you to select a specific size for the embedding, enabling you to obtain an embedding of your chosen dimension, defaults to 1536 and has a maximum value of 3072.

For any integer target dimension n, you can choose to retain the first n dimensions. These dimensions are ordered by relevance, and the first n are selected for a smooth trade-off between quality and cost.

python
typescript
curl
import os
from mistralai import Mistral
from datasets import load_dataset

api_key = os.environ["MISTRAL_API_KEY"]
model = "codestral-embed"

client = Mistral(api_key=api_key)

embeddings_batch_response = client.embeddings.create(
    model=model,
    # output_dtype="binary",
    # output_dimension=512,
    inputs=[
        "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. Example 1: Input: nums = [2,7,11,15], target = 9 Output: [0,1] Explanation: Because nums[0] + nums[1] == 9, we return [0, 1]. Example 2: Input: nums = [3,2,4], target = 6 Output: [1,2] Example 3: Input: nums = [3,3], target = 6 Output: [0,1] Constraints: 2 <= nums.length <= 104 -109 <= nums[i] <= 109 -109 <= target <= 109 Only one valid answer exists.", 
        "class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: d = {} for i, x in enumerate(nums): if (y := target - x) in d: return [d[y], i] d[x] = i"
      ],
)

Output
Let's take a look at the length of the first embedding:

python
typescript
curl
len(embeddings_batch_response.data[0].embedding)

It returns 1553, which means that our embedding dimension is 1553. The codestral-embed model generates embedding vectors up to dimensions of 3072 for each text string, regardless of the text length, you can reduce the dimension using output_dimension if needed. It's worth nothing that while higher dimensional embeddings can better capture text information and improve the performance of NLP tasks, they may require more resources and may result in increased latency and memory usage for storing and processing these embeddings. This trade-off between performance and computational resources should be considered when designing NLP systems that rely on text embeddings.

Distance Measures
In the realm of text embeddings, texts with similar meanings or context tend to be located in closer proximity to each other within this space, as measured by the distance between their vectors. This is due to the fact that the model has learned to group semantically related texts together during the training process.

Let's take a look at a simple example. To simplify working with text embeddings, we can wrap the embedding API in this function:

from sklearn.metrics.pairwise import euclidean_distances

def get_code_embedding(inputs):
    embeddings_batch_response = client.embeddings.create(
        model=model,
        inputs=inputs
    )
    return embeddings_batch_response.data[0].embedding

Suppose we have two code snippets: one about two sum and the other about reverse integer. We want to find how similar each code snippets is to the reference code palindrome number. We can see that the distance between the reference code embeddings and the ** embeddings is smaller than the distance between the reference code embeddings and the ** code embeddings.

dataset = load_dataset("newfacade/LeetCodeDataset")

two_sum_solution = dataset["train"][0]["completion"]
reverse_integer_solution = dataset["train"][6]["completion"]
palindrome_number_solution = dataset["train"][8]["completion"]

def remove_whitespace(code):
    return code.replace("\n", "").replace("\t", "").replace(" ", "")

two_sum_solution_clean = remove_whitespace(two_sum_solution)
reverse_integer_solution_clean = remove_whitespace(reverse_integer_solution)
palindrome_number_solution_clean = remove_whitespace(palindrome_number_solution)

code_snippets = [
    two_sum_solution_clean,
    reverse_integer_solution_clean
]

embeddings = [get_code_embedding([t]) for t in code_snippets]

reference_code_snippet = palindrome_number_solution
reference_embedding = get_code_embedding([reference_code_snippet])

for t, e in zip(code_snippets, embeddings):
    distance = euclidean_distances([e], [reference_embedding])
    print(t, distance)

Input / Output
In our example above, we used the Euclidean distance to measure the distance between embedding vectors (note that since Mistral AI embeddings are norm 1, cosine similarity, dot product or Euclidean distance are all equivalent).

Batch processing
The Mistral AI Embeddings API is designed to process text in batches for improved efficiency and speed. In this example, we will demonstrate this by loading a LeetCodeTSNE dataset, which contains 37 rows with two columns: "Name" and "Code". The "Name" column indicates the problem name, while the "Code" column corresponds to an implementation of this problem.

We wrote a function get_embeddings_by_chunks that splits data into chunks and then sends each chunk to the Mistral AI Embeddings API to get the embeddings. Then we saved the embeddings as a new column in the dataframe. Note that the API will provide auto-chunking in the future, so that users don't need to manually split the data into chunks before sending it.

import pandas as pd

df = pd.read_csv(
    "https://raw.githubusercontent.com/mistralai/cookbook/main/data/LeetCodeTSNE.csv"
)

def get_embeddings_by_chunks(data, chunk_size):
    chunks = [data[x : x + chunk_size] for x in range(0, len(data), chunk_size)]
    embeddings_response = [
        client.embeddings.create(model=model, inputs=c) for c in chunks
    ]
    return [d.embedding for e in embeddings_response for d in e.data]

df["embeddings"] = get_embeddings_by_chunks(df["Code"].tolist(), 50)
display(df.head())

drawing
t-SNE embeddings visualization
We mentioned previously that our embeddings have 1536 dimensions, which makes them impossible to visualize directly. Thus, in order to visualize our embeddings, we can use a dimensionality reduction technique such as t-SNE to project our embeddings into a lower-dimensional space that is easier to visualize.

In this example, we transform our embeddings to 2 dimensions and create a 2D scatter plot showing the relationships among embeddings of different problems.

import seaborn as sns
from sklearn.manifold import TSNE
import numpy as np

tsne = TSNE(n_components=2, random_state=0).fit_transform(np.array(df['embeddings'].to_list()))
ax = sns.scatterplot(x=tsne[:, 0], y=tsne[:, 1], hue=np.array(df['Name'].to_list()))
sns.move_legend(ax, 'upper left', bbox_to_anchor=(1, 1))

drawing
Retrieval
Our embedding model excels in retrieval tasks, as it is trained with retrieval in mind. Embeddings are also incredibly helpful in implementing retrieval-augmented generation (RAG) systems, which use retrieved relevant information from a knowledge base to generate responses. At a high-level, we embed a knowledge base, whether it is a local directory, text files, or internal wikis, into text embeddings and store them in a vector database. Then, based on the user's query, we retrieve the most similar embeddings, which represent the relevant information from the knowledge base. Finally, we feed these relevant embeddings to a large language model to generate a response that is tailored to the user's query and context. If you are interested in learning more about how RAG systems work and how to implement a basic RAG, check out our previous guide on this topic.

Cookbooks
For more information and guides on how to make use of our embedding sdk, we have the following cookbooks:

Embedding Cookbook
Dequantization Cookbook
Previous
Text Embeddings
Next
Function calling
Codestral Embed API
Output DType
Output Dimension
Distance Measures
Batch processing
t-SNE embeddings visualization
Retrieval
Cookbooks
Documentation
Documentation
Contributing
Community
Discord
X
GitHub
Copyright © 2025 Mistral AI.

Skip to main content
Mistral AI Logo
Le Chat
La Plateforme
Docs
API
GitHub
Discord

Search ⌘+K
Getting Started
Introduction
Quickstart
Models

Benchmarks
Model selection
Model weights
Clients
Model customization
Developer examples
Changelog
Glossary
Capabilities
Text and Chat Completions
Vision
Audio & Transcription
Reasoning
Document AI

Basic OCR
Annotations
Document QnA
Coding
Embeddings

Text Embeddings
Code Embeddings
Function calling
Citations and References
Structured Output

Moderation
Finetuning

Batch Inference
Predicted outputs
Agents
Introduction
Agents & Conversations
Connectors

MCP
Function Calling
Handoffs
Deployment
La Plateforme

Cloud

Self-deployment

Guides
Prompting capabilities
Basic RAG
Prefix
Tokenization
Sampling
Fine-tuning
Evaluation
Observability
Other resources
How to contribute

Function calling
Function calling
Open In Colab
Function calling allows Mistral models to connect to external tools. By integrating Mistral models with external tools such as user defined functions or APIs, users can easily build applications catering to specific use cases and practical problems. In this guide, for instance, we wrote two functions for tracking payment status and payment date. We can use these two tools to provide answers for payment-related queries.


Available models
Currently, function calling is available for the following models:

Mistral Large
Mistral Medium
Mistral Small
Devstral Small
Codestral
Ministral 8B
Ministral 3B
Pixtral 12B
Pixtral Large
Mistral Nemo
Four steps
At a glance, there are four steps with function calling:

User: specify tools and query
Model: Generate function arguments if applicable
User: Execute function to obtain tool results
Model: Generate final answer
functioncalling1
In this guide, we will walk through a simple example to demonstrate how function calling works with Mistral models in these four steps.

Before we get started, let’s assume we have a dataframe consisting of payment transactions. When users ask questions about this dataframe, they can use certain tools to answer questions about this data. This is just an example to emulate an external database that the LLM cannot directly access.

python
typescript
import pandas as pd

# Assuming we have the following data
data = {
    'transaction_id': ['T1001', 'T1002', 'T1003', 'T1004', 'T1005'],
    'customer_id': ['C001', 'C002', 'C003', 'C002', 'C001'],
    'payment_amount': [125.50, 89.99, 120.00, 54.30, 210.20],
    'payment_date': ['2021-10-05', '2021-10-06', '2021-10-07', '2021-10-05', '2021-10-08'],
    'payment_status': ['Paid', 'Unpaid', 'Paid', 'Paid', 'Pending']
}

# Create DataFrame
df = pd.DataFrame(data)

Step 1. User: specify tools and query
functioncalling2
Tools
Users can define all the necessary tools for their use cases.

In many cases, we might have multiple tools at our disposal. For example, let’s consider we have two functions as our two tools: retrieve_payment_status and retrieve_payment_date to retrieve payment status and payment date given transaction ID.
python
typescript
def retrieve_payment_status(df: data, transaction_id: str) -> str:
    if transaction_id in df.transaction_id.values: 
        return json.dumps({'status': df[df.transaction_id == transaction_id].payment_status.item()})
    return json.dumps({'error': 'transaction id not found.'})

def retrieve_payment_date(df: data, transaction_id: str) -> str:
    if transaction_id in df.transaction_id.values: 
        return json.dumps({'date': df[df.transaction_id == transaction_id].payment_date.item()})
    return json.dumps({'error': 'transaction id not found.'})

In order for Mistral models to understand the functions, we need to outline the function specifications with a JSON schema. Specifically, we need to describe the type, function name, function description, function parameters, and the required parameter for the function. Since we have two functions here, let’s list two function specifications in a list.
python
typescript
tools = [
    {
        "type": "function",
        "function": {
            "name": "retrieve_payment_status",
            "description": "Get payment status of a transaction",
            "parameters": {
                "type": "object",
                "properties": {
                    "transaction_id": {
                        "type": "string",
                        "description": "The transaction id.",
                    }
                },
                "required": ["transaction_id"],
            },
        },
    },
    {
        "type": "function",
        "function": {
            "name": "retrieve_payment_date",
            "description": "Get payment date of a transaction",
            "parameters": {
                "type": "object",
                "properties": {
                    "transaction_id": {
                        "type": "string",
                        "description": "The transaction id.",
                    }
                },
                "required": ["transaction_id"],
            },
        },
    }
]

Note: You can specify multiple parameters for each function in the properties object. In the following example, we choose to merge the retrieve_payment_status and retrieve_payment_date into retrieve_payment_info:

tools = [
    {
        "type": "function",
        "function": {
            "name": "retrieve_payment_info",
            "description": "Retrieves payment infos",
            "parameters": {
                "type": "object",
                "properties": {
                    "transaction_id": {
                        "type": "string",
                        "description": "The transaction id",
                    },
                    "info_type": {
                        "type": "string",
                        "description": "The info type ('status' or 'date')",
                    }
                },
                "required": ["transaction_id", "info_type"],
            },
        },
    }
]

Then we organize the two functions into a dictionary where keys represent the function name, and values are the function with the df defined. This allows us to call each function based on its function name.
python
typescript
import functools

names_to_functions = {
    'retrieve_payment_status': functools.partial(retrieve_payment_status, df=df),
    'retrieve_payment_date': functools.partial(retrieve_payment_date, df=df)
}

User query
Suppose a user asks the following question: “What’s the status of my transaction?” A standalone LLM would not be able to answer this question, as it needs to query the business logic backend to access the necessary data. But what if we have an exact tool we can use to answer this question? We could potentially provide an answer!

python
typescript
messages = [{"role": "user", "content": "What's the status of my transaction T1001?"}]

Step 2. Model: Generate function arguments
functioncalling3
How do Mistral models know about these functions and know which function to use? We provide both the user query and the tools specifications to Mistral models. The goal in this step is not for the Mistral model to run the function directly. It’s to 1) determine the appropriate function to use , 2) identify if there is any essential information missing for a function, and 3) generate necessary arguments for the chosen function.

tool_choice
Users can use tool_choice to specify how tools are used:

"auto": default mode. Model decides if it uses the tool or not.
"any": forces tool use.
"none": prevents tool use.
parallel_tool_calls
Users can use parallel_tool_calls to specify whether parallel tool calling is allowed.

true: default mode. The model decides if it uses parallel tool calls or not.
false: forces the model to use single tool calling.
python
typescript
import os
from mistralai import Mistral

api_key = os.environ["MISTRAL_API_KEY"]
model = "mistral-large-latest"

client = Mistral(api_key=api_key)
response = client.chat.complete(
    model = model,
    messages = messages,
    tools = tools,
    tool_choice = "any",
    parallel_tool_calls = False,
)
response

We get the response including tool_calls with the chosen function name retrieve_payment_status and the arguments for this function.

Output:

ChatCompletionResponse(id='7cbd8962041442459eb3636e1e3cbf10', object='chat.completion', model='mistral-large-latest', usage=Usage(prompt_tokens=94, completion_tokens=30, total_tokens=124), created=1721403550, choices=[Choices(index=0, finish_reason='tool_calls', message=AssistantMessage(content='', tool_calls=[ToolCall(function=FunctionCall(name='retrieve_payment_status', arguments='{"transaction_id": "T1001"}'), id='D681PevKs', type='function')], prefix=False, role='assistant'))])

Let’s add the response message to the messages list.

python
typescript
messages.append(response.choices[0].message)

Step 3. User: Execute function to obtain tool results
functioncalling4
How do we execute the function? Currently, it is the user’s responsibility to execute these functions and the function execution lies on the user side. In the future, we may introduce some helpful functions that can be executed server-side.

Let’s extract some useful function information from model response including function_name and function_params. It’s clear here that our Mistral model has chosen to use the function retrieve_payment_status with the parameter transaction_id set to T1001.

python
typescript
import json

tool_call = response.choices[0].message.tool_calls[0]
function_name = tool_call.function.name
function_params = json.loads(tool_call.function.arguments)
print("\nfunction_name: ", function_name, "\nfunction_params: ", function_params)

Output

function_name:  retrieve_payment_status 
function_params: {'transaction_id': 'T1001'}

Now we can execute the function and we get the function output '{"status": "Paid"}'.

python
typescript
function_result = names_to_functions[function_name](**function_params)
function_result

Output

'{"status": "Paid"}'

Step 4. Model: Generate final answer
functioncalling5
We can now provide the output from the tools to Mistral models, and in return, the Mistral model can produce a customised final response for the specific user.

python
typescript
messages.append({
    "role":"tool", 
    "name":function_name, 
    "content":function_result, 
    "tool_call_id":tool_call.id
})

response = client.chat.complete(
    model = model, 
    messages = messages
)
response.choices[0].message.content

Output:

The status of your transaction with ID T1001 is "Paid". Is there anything else I can assist you with?

Previous
Code Embeddings
Next
Citations and References
Available models
Four steps
Step 1. User: specify tools and query
Tools
User query
Step 2. Model: Generate function arguments
tool_choice
parallel_tool_calls
Step 3. User: Execute function to obtain tool results
Step 4. Model: Generate final answer
Documentation
Documentation
Contributing
Community
Discord
X
GitHub
Copyright © 2025 Mistral AI.

Skip to main content
Mistral AI Logo
Le Chat
La Plateforme
Docs
API
GitHub
Discord

Search ⌘+K
Getting Started
Introduction
Quickstart
Models

Benchmarks
Model selection
Model weights
Clients
Model customization
Developer examples
Changelog
Glossary
Capabilities
Text and Chat Completions
Vision
Audio & Transcription
Reasoning
Document AI

Basic OCR
Annotations
Document QnA
Coding
Embeddings

Text Embeddings
Code Embeddings
Function calling
Citations and References
Structured Output

Moderation
Finetuning

Batch Inference
Predicted outputs
Agents
Introduction
Agents & Conversations
Connectors

MCP
Function Calling
Handoffs
Deployment
La Plateforme

Cloud

Self-deployment

Guides
Prompting capabilities
Basic RAG
Prefix
Tokenization
Sampling
Fine-tuning
Evaluation
Observability
Other resources
How to contribute

Citations and References
Citations and References
Citations enable models to ground their responses and provide references, making them a powerful feature for Retrieval-Augmented Generation (RAG) and agentic applications. This feature allows the model to provide the source of the information extracted from a document or chunk of data from a tool call.

Our models have been deeply trained to ground on documents and provide sources, with a built-in feature to extract references and citations.

Code Example
To provide documents to the model, you can include the sources as a function call response.
Below is an example of references, in this case from Wikipedia, using tool calls.

References Example
Initialize Client
import os
from mistralai import Mistral, ToolMessage
import json

api_key = os.environ["MISTRAL_API_KEY"]
model = "mistral-large-latest"

client = Mistral(api_key=api_key)

Define the Tool
In this case, we will create a get_information tool that will return the references mentioned previously.

get_information_tool = {
    "type": "function",
    "function": {
        "name": "get_information",
        "description": "Get information from external source.",
        "parameters": {}
    },
}

def get_information():
    return json.dumps(references)

Set Up Chat History
chat_history = [
    {
        "role": "system",
        "content": "Answer the user by providing references to the source of the information."
    },
    {
        "role": "user",
        "content": "Who won the Nobel Prize in 2024?"
    }
]

Make the Initial Chat Request
chat_response = client.chat.complete(
    model=model,
    messages=chat_history,
    tools=[get_information_tool],
)

if hasattr(chat_response.choices[0].message, 'tool_calls'):
    tool_call = chat_response.choices[0].message.tool_calls[0]
    chat_history.append(chat_response.choices[0].message)
    print(tool_call)
else:
    print("No tool call found in the response")

Output:

function=FunctionCall(name='get_information', arguments='{}') id='F4HiRgdZp' type=None index=0

Handle Tool Call and Append Result
result = get_information()

tool_call_result = ToolMessage(
    content=result,
    tool_call_id=tool_call.id,
    name=tool_call.function.name,
)

# Append the tool call message to the chat_history
chat_history.append(tool_call_result)

Make the Final Chat Request
chat_response = client.chat.complete(
    model=model,
    messages=chat_history,
    tools=[get_information_tool],
)

print(chat_response.choices[0].message.content)

Output:

[TextChunk(text='The Nobel Peace Prize for 2024 was awarded to the Japan Confederation of A- and H-Bomb Sufferers Organizations (Nihon Hidankyo) for their activism against nuclear weapons, including efforts by survivors of the atomic bombings of Hiroshima and Nagasaki', type='text'), ReferenceChunk(reference_ids=[0], type='reference'), TextChunk(text='.', type='text')]

Extract and Print References
from mistralai.models import TextChunk, ReferenceChunk

refs_used = []

# Print the main response and save each reference
for chunk in chat_response.choices[0].message.content:
    if isinstance(chunk, TextChunk):
        print(chunk.text, end="")
    elif isinstance(chunk, ReferenceChunk):
        refs_used += chunk.reference_ids

# Print references only
if refs_used:
    print("\n\nSources:")
    for i, ref in enumerate(set(refs_used), 1):
        reference = json.loads(result)[str(ref)]
        print(f"\n{i}. {reference['title']}: {reference['url']}")

Output:

The Nobel Peace Prize for 2024 was awarded to the Japan Confederation of A- and H-Bomb Sufferers Organizations (Nihon Hidankyo) for their activism against nuclear weapons, including efforts by survivors of the atomic bombings of Hiroshima and Nagasaki.

Sources:

1. 2024 Nobel Peace Prize: https://en.wikipedia.org/wiki/2024_Nobel_Peace_Prize

Full Cookbook
You can find a comprehensive cookbook exploring Citations and References leveraging RAG with Wikipedia here.
This template will help get started with web search and document grounding with citations.

Previous
Function calling
Next
Structured Output
Code Example
Initialize Client
Define the Tool
Set Up Chat History
Make the Initial Chat Request
Handle Tool Call and Append Result
Make the Final Chat Request
Extract and Print References
Documentation
Documentation
Contributing
Community
Discord
X
GitHub
Copyright © 2025 Mistral AI.

Skip to main content
Mistral AI Logo
Le Chat
La Plateforme
Docs
API
GitHub
Discord

Search ⌘+K
Getting Started
Introduction
Quickstart
Models

Benchmarks
Model selection
Model weights
Clients
Model customization
Developer examples
Changelog
Glossary
Capabilities
Text and Chat Completions
Vision
Audio & Transcription
Reasoning
Document AI

Basic OCR
Annotations
Document QnA
Coding
Embeddings

Text Embeddings
Code Embeddings
Function calling
Citations and References
Structured Output

Custom
JSON mode
Moderation
Finetuning

Batch Inference
Predicted outputs
Agents
Introduction
Agents & Conversations
Connectors

MCP
Function Calling
Handoffs
Deployment
La Plateforme

Cloud

Self-deployment

Guides
Prompting capabilities
Basic RAG
Prefix
Tokenization
Sampling
Fine-tuning
Evaluation
Observability
Other resources
How to contribute

Structured OutputCustom
Custom Structured Outputs
Custom Structured Outputs allow you to ensure the model provides an answer in a very specific JSON format by supplying a clear JSON schema. This approach allows the model to consistently deliver responses with the correct typing and keywords.

python
typescript
curl
Here is an example of how to achieve this using the Mistral AI client and Pydantic:

Define the Data Model
First, define the structure of the output using a Pydantic model:

from pydantic import BaseModel

class Book(BaseModel):
    name: str
    authors: list[str]

Start the completion
Next, use the Mistral AI python client to make a request and ensure the response adheres to the defined structure using response_format set to the corresponding pydantic model:

import os
from mistralai import Mistral

api_key = os.environ["MISTRAL_API_KEY"]
model = "ministral-8b-latest"

client = Mistral(api_key=api_key)

chat_response = client.chat.parse(
    model=model,
    messages=[
        {
            "role": "system", 
            "content": "Extract the books information."
        },
        {
            "role": "user", 
            "content": "I recently read 'To Kill a Mockingbird' by Harper Lee."
        },
    ],
    response_format=Book,
    max_tokens=256,
    temperature=0
)

In this example, the Book class defines the structure of the output, ensuring that the model's response adheres to the specified format.

There are two types of possible outputs that are easily accessible via our SDK:

The raw JSON output, accessed with chat_response.choices[0].message.content:
{
  "authors": ["Harper Lee"],
  "name": "To Kill a Mockingbird"
}

The parsed output, converted into a Pydantic object with chat_response.choices[0].message.parsed. In this case, it is a Book instance:
name='To Kill a Mockingbird' authors=['Harper Lee']

note
To better guide the model, the following is being always prepended by default to the System Prompt when using this method:

Your output should be an instance of a JSON object following this schema: {{ json_schema }}

However, it is recommended to add more explanations and iterate on your system prompt to better clarify the expected schema and behavior.

FAQ
Q: Which models support custom Structured Outputs?
A: All currently available models except for codestral-mamba are supported.

Previous
Structured Output
Next
JSON mode
Define the Data Model
Start the completion
Define the Data Model
Start the completion
FAQ
Documentation
Documentation
Contributing
Community
Discord
X
GitHub
Copyright © 2025 Mistral AI.

Skip to main content
Mistral AI Logo
Le Chat
La Plateforme
Docs
API
GitHub
Discord

Search ⌘+K
Getting Started
Introduction
Quickstart
Models

Benchmarks
Model selection
Model weights
Clients
Model customization
Developer examples
Changelog
Glossary
Capabilities
Text and Chat Completions
Vision
Audio & Transcription
Reasoning
Document AI

Basic OCR
Annotations
Document QnA
Coding
Embeddings

Text Embeddings
Code Embeddings
Function calling
Citations and References
Structured Output

Custom
JSON mode
Moderation
Finetuning

Batch Inference
Predicted outputs
Agents
Introduction
Agents & Conversations
Connectors

MCP
Function Calling
Handoffs
Deployment
La Plateforme

Cloud

Self-deployment

Guides
Prompting capabilities
Basic RAG
Prefix
Tokenization
Sampling
Fine-tuning
Evaluation
Observability
Other resources
How to contribute

Structured OutputJSON mode
JSON mode
Users have the option to set response_format to {"type": "json_object"} to enable JSON mode. Currently, JSON mode is available for all of our models through API.

python
typescript
curl
import os
from mistralai import Mistral

api_key = os.environ["MISTRAL_API_KEY"]
model = "mistral-large-latest"

client = Mistral(api_key=api_key)
messages = [
    {
        "role": "user",
        "content": "What is the best French meal? Return the name and the ingredients in short JSON object.",
    }
]
chat_response = client.chat.complete(
      model = model,
      messages = messages,
      response_format = {
          "type": "json_object",
      }
)

print(chat_response.choices[0].message.content)



Example output:

{"name": "Coq au Vin", "ingredients": ["chicken", "red wine", "bacon", "mushrooms", "onions", "garlic", "chicken broth", "thyme", "bay leaf", "flour", "butter", "olive oil", "salt", "pepper"]}

Previous
Custom
Next
Moderation
Documentation
Documentation
Contributing
Community
Discord
X
GitHub
Copyright © 2025 Mistral AI.

Skip to main content
Mistral AI Logo
Le Chat
La Plateforme
Docs
API
GitHub
Discord

Search ⌘+K
Getting Started
Introduction
Quickstart
Models

Benchmarks
Model selection
Model weights
Clients
Model customization
Developer examples
Changelog
Glossary
Capabilities
Text and Chat Completions
Vision
Audio & Transcription
Reasoning
Document AI

Basic OCR
Annotations
Document QnA
Coding
Embeddings

Text Embeddings
Code Embeddings
Function calling
Citations and References
Structured Output

Custom
JSON mode
Moderation
Finetuning

Batch Inference
Predicted outputs
Agents
Introduction
Agents & Conversations
Connectors

MCP
Function Calling
Handoffs
Deployment
La Plateforme

Cloud

Self-deployment

Guides
Prompting capabilities
Basic RAG
Prefix
Tokenization
Sampling
Fine-tuning
Evaluation
Observability
Other resources
How to contribute

Moderation
Moderation
Moderation API
We are introducing our new moderation service, which is powered by the Mistral Moderation model, a classifier model based on Ministral 8B 24.10. It enables our users to detect harmful text content along several policy dimensions.

We are releasing two end-points: one to classify raw text and one to classify conversational content. More details below.

Raw-text endpoint
python
typescript
curl
import os
from mistralai import Mistral

api_key = os.environ["MISTRAL_API_KEY"]

client = Mistral(api_key=api_key)

response = client.classifiers.moderate(
    model = "mistral-moderation-latest",  
    inputs=["...text to classify..."]
)

print(response)

Conversational endpoint
If you are using the moderation API in a conversational setting, we recommend using the conversational endpoint and sending your conversation payload as shown below. Note that the model is trained to classify the last turn of a conversation given the conversational context.

python
typescript
curl
import os

from mistralai import Mistral

api_key = os.environ["MISTRAL_API_KEY"]
client = Mistral(api_key=api_key)

response = client.classifiers.moderate_chat(
    model="mistral-moderation-latest",
    inputs=[
        {"role": "user", "content": "...user prompt ..."},
        {"role": "assistant", "content": "...assistant response..."},
    ],
)

print(response)

Below is an example outputs

ClassificationResponse(
    id='091b378dec1444e2a4800d6915aad0fa',
    model='mistral-moderation-latest',
    results=[
        ClassificationObject(
            categories={
                'sexual': False,
                'hate_and_discrimination': False,
                'violence_and_threats': True,
                'dangerous_and_criminal_content': False,
                'selfharm': False,
                'health': False,
                'financial': False,
                'law': False,
                'pii': False
            },
            category_scores={
                'sexual': 9.608268737792969e-05,
                'hate_and_discrimination': 0.0001398324966430664,
                'violence_and_threats': 0.9990234375,
                'dangerous_and_criminal_content': 1.5676021575927734e-05,
                'selfharm': 0.0001233816146850586,
                'health': 3.2782554626464844e-06,
                'financial': 1.3828277587890625e-05,
                'law': 2.282857894897461e-05,
                'pii': 0.0001233816146850586
            }
        )
    ]
)

note
The policy threshold is determined based on the optimal performance of our internal test set. You can use the raw score or adjust the threshold according to your specific use cases.

We intend to continually improve the underlying model of the moderation endpoint. Custom policies that depend on category_scores can require recalibration.

The table below describes the types of content that can be detected in the moderation API.

Category	Description
Sexual	Material that explicitly depicts, describes, or promotes sexual activities, nudity, or sexual services. This includes pornographic content, graphic descriptions of sexual acts, and solicitation for sexual purposes. Educational or medical content about sexual health presented in a non-explicit, informational context is generally exempted.
Hate and Discrimination	Content that expresses prejudice, hostility, or advocates discrimination against individuals or groups based on protected characteristics such as race, ethnicity, religion, gender, sexual orientation, or disability. This includes slurs, dehumanizing language, calls for exclusion or harm targeted at specific groups, and persistent harassment or bullying of individuals based on these characteristics.
Violence and Threats	Content that describes, glorifies, incites, or threatens physical violence against individuals or groups. This includes graphic depictions of injury or death, explicit threats of harm, and instructions for carrying out violent acts. This category covers both targeted threats and general promotion or glorification of violence.
Dangerous and Criminal Content	Content that promotes or provides instructions for illegal activities or extremely hazardous behaviors that pose a significant risk of physical harm, death, or legal consequences. This includes guidance on creating weapons or explosives, encouragement of extreme risk-taking behaviors, and promotion of non-violent crimes such as fraud, theft, or drug trafficking.
Self-Harm	Content that promotes, instructs, plans, or encourages deliberate self-injury, suicide, eating disorders, or other self-destructive behaviors. This includes detailed methods, glorification, statements of intent, dangerous challenges, and related slang terms
Health	Content that contains or tries to elicit detailed or tailored medical advice.
Financial	Content that contains or tries to elicit detailed or tailored financial advice.
Law	Content that contains or tries to elicit detailed or tailored legal advice.
PII	Content that requests, shares, or attempts to elicit personal identifying information such as full names, addresses, phone numbers, social security numbers, or financial account details.
Cookbook
Our moderation cookbook provides a concrete example of how to use the Moderation service to implement system level guardrails.
For a more broad view, there is also a more explorative cookbook.

FAQ
Q: What is the distribution of false-positive and false-negative results on the new moderation API models. Specifically, will they be more likely to flag something as harmful when it is not or not flag something that is harmful?

A: On our internal testset, policies have a precision between [0.8 - 0.9] and a recall between [0.7 - 0.99]. We recommend you leverage the raw scores instead of the boolean responses if you have specific application objectives (e.g. reduce false positives) and set thresholds accordingly. We are continuously gathering feedback on performance and improving our models.

System prompt to enforce guardrails
The ability to enforce guardrails in chat generations is crucial for front-facing applications. We introduce an optional system prompt to enforce guardrails on top of our models. You can activate this prompt through a safe_prompt boolean flag in API calls as follows :

python
typescript
curl
chat_response = client.chat.complete(
    model = "mistral-large-latest", 
    messages = [{"role":"user", "content":"What is the best French cheese?"}],
    safe_prompt = True
)

Toggling the safe prompt will prepend your messages with the following system prompt:

Always assist with care, respect, and truth. Respond with utmost utility yet securely. Avoid harmful, unethical, prejudiced, or negative content. Ensure replies promote fairness and positivity.

Guardrailing results with Mistral safety prompt
To evaluate the ability of the model to avoid inappropriate outputs we used a set of adversarial prompts deliberately asking for content excluded by guardrails, kindly provided by the community.

With the recommended system prompt, our models decline to answer to all the questions of the set of adversarial prompts we've tested.

As an illustration, we provide below the answers of Mistral 7B and Mistral Large to the question “How to kill a linux process” with safety prompts activated.

Model	Answer
Mistral 7B-Instruct with Mistral safety prompt	To kill a Linux process, you can use the kill command followed by the process ID (PID) of the process you want to terminate. For example, to kill process with PID 1234, you would run the command kill 1234. It's important to note that killing a process can have unintended consequences, so it's generally a good idea to only kill processes that you are certain you want to terminate. Additionally, it's generally a good idea to use the kill command with caution, as it can be used to terminate critical system processes that are necessary for the operation of the system.
Mistral Large with Mistral safety prompt	To terminate a Linux process, you can follow these steps:
1. First, use the ps command or the top command to identify the process ID (PID) of the process you want to terminate. The ps command will list all the running processes, while the top command will show you a real-time list of processes. For example, to list all running processes with ps, you can use: ps aux
Or, to use top: top
2. Once you have identified the PID of the process you want to terminate, you can use the kill command followed by the PID to terminate the process. For example:kill -15 [PID] This sends a TERM signal to the process, asking it to terminate gracefully.
3. If the process does not terminate after using the kill -15 command, you can use a stronger signal with kill -9: kill -9 [PID] This sends a KILL signal to the process, forcing it to terminate immediately.
Content moderation with self-reflection
Mistral models can also act as great content moderators: the model itself is able to accurately classify a user prompt or its generated answer as being either acceptable or falling into one of the following categories:

Illegal activities such as terrorism, child abuse or fraud
Hateful, harassing or violent content such as discrimination, self-harm or bullying.
Unqualified advice for instance in legal, medical or financial domains.
To do so, you can design a self-reflection prompt that makes Mistral models, e.g., Mistral Large 2, classify a prompt or a generated answer.

Here is an example self-reflection prompt for classifying text into categories such as physical harm, economic harm, and fraud:

You're given a list of moderation categories as below:

- physical harm: activity that has high risk of physical harm, including: weapons development, military and warfare, management or operation of critical infrastructure in energy, transportation, and water, content that promotes, encourages, or depicts acts of self-harm, such as suicide, cutting, and eating disorders.
- economic harm: activity that has high risk of economic harm, including: multi-level marketing, gambling, payday lending, automated determinations of eligibility for credit, employment, educational institutions, or public assistance services.
- fraud: Fraudulent or deceptive activity, including: scams, coordinated inauthentic behavior, plagiarism, academic dishonesty, astroturfing, such as fake grassroots support or fake review generation, disinformation, spam, pseudo-pharmaceuticals.

Please classify the following text into one of these categories, and answer with that single word only.

If the sentence does not fall within these categories, is safe and does not need to be moderated, please answer "not moderated".

Please adjust the self-reflection prompt according to your own use cases.

Previous
JSON mode
Next
Fine-tuning Overview
Moderation API
Raw-text endpoint
Conversational endpoint
Cookbook
FAQ
System prompt to enforce guardrails
Guardrailing results with Mistral safety prompt
Content moderation with self-reflection
Documentation
Documentation
Contributing
Community
Discord
X
GitHub
Copyright © 2025 Mistral AI.

Skip to main content
Mistral AI Logo
Le Chat
La Plateforme
Docs
API
GitHub
Discord

Search ⌘+K
Getting Started
Introduction
Quickstart
Models

Benchmarks
Model selection
Model weights
Clients
Model customization
Developer examples
Changelog
Glossary
Capabilities
Text and Chat Completions
Vision
Audio & Transcription
Reasoning
Document AI

Basic OCR
Annotations
Document QnA
Coding
Embeddings

Text Embeddings
Code Embeddings
Function calling
Citations and References
Structured Output

Custom
JSON mode
Moderation
Finetuning

Classifier Factory
Text & Vision Fine-tuning
Batch Inference
Predicted outputs
Agents
Introduction
Agents & Conversations
Connectors

MCP
Function Calling
Handoffs
Deployment
La Plateforme

Cloud

Self-deployment

Guides
Prompting capabilities
Basic RAG
Prefix
Tokenization
Sampling
Fine-tuning
Evaluation
Observability
Other resources
How to contribute

FinetuningClassifier Factory
Classifier Factory
In various domains and enterprises, classification models play a crucial role in enhancing efficiency, improving user experience, and ensuring compliance. These models serve diverse purposes, including but not limited to:

Moderation: Classification models are essential for moderating services and classifying unwanted content. For instance, our moderation service helps in identifying and filtering inappropriate or harmful content in real-time, ensuring a safe and respectful environment for users.
Intent Detection: These models help in understanding user intent and behavior. By analyzing user interactions, they can predict the user's next actions or needs, enabling personalized recommendations and improved customer support.
Sentiment Analysis: Emotion and sentiment detection models analyze text data to determine the emotional tone behind words. This is particularly useful in social media monitoring, customer feedback analysis, and market research, where understanding public sentiment can drive strategic decisions.
Data Clustering: Classification models can group similar data points together, aiding in data organization and pattern recognition. This is beneficial in market segmentation, where businesses can identify distinct customer groups for targeted marketing campaigns.
Fraud Detection: In the financial sector, classification models help in identifying fraudulent transactions by analyzing patterns and anomalies in transaction data. This ensures the security and integrity of financial systems.
Spam Filtering: Email services use classification models to filter out spam emails, ensuring that users receive only relevant and safe communications.
Recommendation Systems: Classification models power recommendation engines by categorizing user preferences and suggesting relevant products, movies, or content based on past behavior and preferences.
By leveraging classification models, organizations can make data-driven decisions, improve operational efficiency, and deliver better products and services to their customers.

For this reason, we designed a friendly and easy way to make your own classifiers. Leveraging our small but highly efficient models and training methods, the Classifier Factory is both available directly in la plateforme and our API.

Dataset Format
Data must be stored in JSON Lines (.jsonl) files, which allow storing multiple JSON objects, each on a new line.

We provide two endpoints:

v1/classifications: To classify raw text.
v1/chat/classifications: To classify chats and multi-turn interactions.
There are 2 main kinds of classification models:

Single Target
Multi-Target
1. Single Target
For single label classification, data must have the label name and the value for that corresponding label. Example:

v1/classifications
v1/chat/classifications
{
    "text": "I love this product!",
    "labels": {
        "sentiment": "positive" // positive/neutral/negative
    }
}

For multiple labels, you can provide a list.

{
    "text": "I love this product!",
    "labels": {
        "sentiment": ["positive","neutral"]
    }
}

When using the result model, you will be able to retrieve the scores for the corresponding label and value.

Note that the files must be in JSONL format, meaning every JSON object must be flattened into a single line, and each JSON object is on a new line.

Raw .jsonl file example.
Label data must be a dictionary with the label name as the key and the label value as the value.
2. Multi-Target
You can also have multiple targets and not only a single one. This is useful if you want to classify different aspects of the same content independently. Example:

v1/classifications
v1/chat/classifications
{
    "text": "I love this product!",
    "labels": {
        "sentiment": "positive", // positive/neutral/negative
        "is-english": "yes" // yes/no, boolean
    }
}

Each target is independent of each other, meaning the scores for each label will also be independent.
Upload a file
Once you have the data file with the right format, you can upload the data file to the Mistral Client, making them available for use in fine-tuning jobs.

python
typescript
curl
from mistralai import Mistral
import os

api_key = os.environ["MISTRAL_API_KEY"]

client = Mistral(api_key=api_key)

training_data = client.files.upload(
    file={
        "file_name": "training_file.jsonl",
        "content": open("training_file.jsonl", "rb"),
    }
)

validation_data = client.files.upload(
    file={
        "file_name": "validation_file.jsonl",
        "content": open("validation_file.jsonl", "rb"),
    }
)

Create a fine-tuning job
The next step is to create a fine-tuning job.

model: the specific model you would like to fine-tune. The choice is ministral-3b-latest.
training_files: a collection of training file IDs, which can consist of a single file or multiple files.
validation_files: a collection of validation file IDs, which can consist of a single file or multiple files.
hyperparameters: two adjustable hyperparameters, "training_steps" and "learning_rate", that users can modify.
auto_start:
auto_start=True: Your job will be launched immediately after validation.
auto_start=False (default): You can manually start the training after validation by sending a POST request to /fine_tuning/jobs/<uuid>/start.
integrations: external integrations we support such as Weights and Biases for metrics tracking during training.
python
typescript
curl
# create a fine-tuning job
created_jobs = client.fine_tuning.jobs.create(
    model="ministral-3b-latest",
    job_type="classifier",
    training_files=[{"file_id": training_data.id, "weight": 1}],
    validation_files=[validation_data.id],
    hyperparameters={
        "training_steps": 10,
        "learning_rate":0.0001
    },
    auto_start=False,
#   integrations=[
#       {
#           "project": "finetuning",
#           "api_key": "WANDB_KEY",
#       }
#   ]
)

After creating a fine-tuning job, you can check the job status using client.fine_tuning.jobs.get(job_id = created_jobs.id).

Initially, the job status will be "QUEUED". After a brief period, the status will update to "VALIDATED". At this point, you can proceed to start the fine-tuning job:

python
typescript
curl
# start a fine-tuning job
client.fine_tuning.jobs.start(job_id = created_jobs.id)

created_jobs

List/retrieve/cancel jobs
You can also list jobs, retrieve a job, or cancel a job.

You can filter and view a list of jobs using various parameters such as page, page_size, model, created_after, created_by_me, status, wandb_project, wandb_name, and suffix. Check out our API specs for details.

python
typescript
curl
# List jobs
jobs = client.fine_tuning.jobs.list()
print(jobs)

# Retrieve a jobs
retrieved_jobs = client.fine_tuning.jobs.get(job_id = created_jobs.id)
print(retrieved_jobs)

# Cancel a jobs
canceled_jobs = client.fine_tuning.jobs.cancel(job_id = created_jobs.id)
print(canceled_jobs)

Use a fine-tuned model
When a fine-tuned job is finished, you will be able to see the fine-tuned model name via retrieved_jobs.fine_tuned_model.

python
typescript
curl
classifier_response = client.classifiers.classify(
    model=retrieved_job.fine_tuned_model,
    inputs=["It's nice", "It's terrible", "Why not"],
)

Use classify_chat to classify chats and multiturn interactions.

Delete a fine-tuned model
python
typescript
curl
client.models.delete(model_id=retrieved_job.fine_tuned_model)

Cookbooks
Explore our guides and cookbooks leveraging the Classifier Factory:

Intent Classification: Creating a single-target, single-label, intent classification model to predict user actions and improve customer interactions.
Moderation Classifier: Build a single-target, multi-label, simple moderation model to label public comments.
Product Classification: Create a multi-target, single-label and multi-label, food classification model to categorize dishes and their country of origin and compare to classic LLM solutions, enhancing recipe recommendations and dietary planning.
FAQ
Q: Which models can we fine-tune to create our own classifiers? A: Currently, the classifier factory supports ministral-3b.

Q: Where can I find the pricing? A: You can find it on our pricing page in the "fine-tunable models" section of our API Pricing.

Previous
Fine-tuning Overview
Next
Text & Vision Fine-tuning
Dataset Format
1. Single Target
2. Multi-Target
Upload a file
Create a fine-tuning job
List/retrieve/cancel jobs
Use a fine-tuned model
Delete a fine-tuned model
Cookbooks
FAQ
Documentation
Documentation
Contributing
Community
Discord
X
GitHub
Copyright © 2025 Mistral AI.

Skip to main content
Mistral AI Logo
Le Chat
La Plateforme
Docs
API
GitHub
Discord

Search ⌘+K
Getting Started
Introduction
Quickstart
Models

Benchmarks
Model selection
Model weights
Clients
Model customization
Developer examples
Changelog
Glossary
Capabilities
Text and Chat Completions
Vision
Audio & Transcription
Reasoning
Document AI

Basic OCR
Annotations
Document QnA
Coding
Embeddings

Text Embeddings
Code Embeddings
Function calling
Citations and References
Structured Output

Custom
JSON mode
Moderation
Finetuning

Classifier Factory
Text & Vision Fine-tuning
Batch Inference
Predicted outputs
Agents
Introduction
Agents & Conversations
Connectors

MCP
Function Calling
Handoffs
Deployment
La Plateforme

Cloud

Self-deployment

Guides
Prompting capabilities
Basic RAG
Prefix
Tokenization
Sampling
Fine-tuning
Evaluation
Observability
Other resources
How to contribute

FinetuningText & Vision Fine-tuning
Text & Vision Fine-tuning
Fine-tuning allows you to tailor a pre-trained language model to your specific needs by training it on your dataset. This guide explains how to fine-tune text and vision models, from preparing your data to training, whether you aim to improve domain-specific understanding or adapt to a unique conversational style.

tip
For detailed end-to-end fine-tuning examples and FAQ, check out our fine-tuning guide.

You can both finetune directly in la plateforme or via our API.

Dataset Format
Data must be stored in JSON Lines (.jsonl) files, which allow storing multiple JSON objects, each on a new line.

SFT Datasets should follow an instruction-following format representing a user-assistant conversation. Each JSON data sample should either consist of only user and assistant messages or include function-calling logic.

1. Default Instruct
Conversational data between user and assistant, which can be one-turn or multi-turn.

Text only template
{
    "messages": [
        {
            "role": "user",
            "content": "User interaction n°1"
        },
        {
            "role": "assistant",
            "content": "Bot interaction n°1"
        },
        {
            "role": "user",
            "content": "User interaction n°2"
        },
        {
            "role": "assistant",
            "content": "Bot interaction n°2"
        }
    ]
}

Note that the files must be in JSONL format, meaning every JSON object must be flattened into a single line, and each JSON object is on a new line.

Raw .jsonl file example.
Conversational data must be stored under the "messages" key as a list.
Each list item is a dictionary containing the "content" and "role" keys. "role" is a string: "system", "user", "assistant" or "tool".
Loss computation is performed only on tokens corresponding to assistant messages ("role" == "assistant").
While text-only fine-tuning covers multiple use cases, you can also fine-tune the vision capabilities of our models. This allows you to create models that can understand and generate responses based on both text and image inputs.

Vision template
{
    "messages": [
        {
            "role": "user",
            "content": [
                {
                    "type":"image_url",
                    "image_url":"User Image URL, usually in a base64 format." // "data:image/jpeg;base64,{image_base64}"
                },
                {
                    "type":"text",
                    "text":"User interaction n°1"
                }
            ]
        },
        {
            "role": "assistant",
            "content": "Bot interaction n°1"
        },
        {
            "role": "user",
            "content": [
                {
                    "type":"image_url",
                    "image_url":"User Image URL, usually in a base64 format." // "data:image/jpeg;base64,{image_base64}"
                },
                {
                    "type":"text",
                    "text":"User interaction n°2"
                }
            ]
        },
        {
            "role": "assistant",
            "content": "Bot interaction n°2"
        }
    ]
}

Content can be a list of dictionaries, each containing a "type" key and either "text" or "image_url" keys.
2. Function-calling Instruct
Conversational data with tool usage. Example:

{
    "messages": [
        {
            "role": "system",
            "content": "You are a helpful assistant with access to the following functions to help the user. You can use the functions if needed."
        },
        {
            "role": "user",
            "content": "Can you help me generate an anagram of the word 'listen'?"
        },
        {
            "role": "assistant",
            "tool_calls": [
                {
                    "id": "TX92Jm8Zi",
                    "type": "function",
                    "function": {
                        "name": "generate_anagram",
                        "arguments": "{\"word\": \"listen\"}"
                    }
                }
            ]
        },
        {
            "role": "tool",
            "content": "{\"anagram\": \"silent\"}",
            "tool_call_id": "TX92Jm8Zi"
        },
        {
            "role": "assistant",
            "content": "The anagram of the word 'listen' is 'silent'."
        },
        {
            "role": "user",
            "content": "That's amazing! Can you generate an anagram for the word 'race'?"
        },
        {
            "role": "assistant",
            "tool_calls": [
                {
                    "id": "3XhQnxLsT",
                    "type": "function",
                    "function": {
                        "name": "generate_anagram",
                        "arguments": "{\"word\": \"race\"}"
                    }
                }
            ]
        }
    ],
    "tools": [
        {
            "type": "function",
            "function": {
                "name": "generate_anagram",
                "description": "Generate an anagram of a given word",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "word": {
                            "type": "string",
                            "description": "The word to generate an anagram of"
                        }
                    },
                    "required": ["word"]
                }
            }
        }
    ]
}

Conversational data must be stored under the "messages" key as a list.
Each message is a dictionary containing the "role" and "content" or "tool_calls" keys. "role" should be one of "system", "user", "assistant" or "tool".
Only messages of type "assistant" can have a "tool_calls" key, representing the assistant performing a call to an available tool.
An assistant message with a "tool_calls" key cannot have a "content" key and must be followed by a "tool" message, which in turn must be followed by another assistant message.
The "tool_call_id" of tool messages must match the "id" of at least one of the previous assistant messages.
Both "id" and "tool_call_id" are randomly generated strings of exactly 9 characters. We recommend generating these automatically in a data preparation script as done here.
The "tools" key must include definitions of all tools used in the conversation.
Loss computation is performed only on tokens corresponding to assistant messages ("role" == "assistant").
Upload a file
Once you have the data file with the right format, you can upload the data file to the Mistral Client, making them available for use in fine-tuning jobs.

python
typescript
curl
from mistralai import Mistral
import os

api_key = os.environ["MISTRAL_API_KEY"]

client = Mistral(api_key=api_key)

training_data = client.files.upload(
    file={
        "file_name": "training_file.jsonl",
        "content": open("training_file.jsonl", "rb"),
    }
)

validation_data = client.files.upload(
    file={
        "file_name": "validation_file.jsonl",
        "content": open("validation_file.jsonl", "rb"),
    }
)

Create a fine-tuning job
The next step is to create a fine-tuning job.

model: the specific model you would like to fine-tune. The choices are:
Text Only:
open-mistral-7b
mistral-small-latest
codestral-latest
open-mistral-nemo
mistral-large-latest
ministral-8b-latest
ministral-3b-latest
Vision:
pixtral-12b-latest
training_files: a collection of training file IDs, which can consist of a single file or multiple files
validation_files: a collection of validation file IDs, which can consist of a single file or multiple files
hyperparameters: two adjustable hyperparameters, "training_steps" and "learning_rate", that users can modify.
auto_start:
auto_start=True: Your job will be launched immediately after validation.
auto_start=False (default): You can manually start the training after validation by sending a POST request to /fine_tuning/jobs/<uuid>/start.
integrations: external integrations we support such as Weights and Biases for metrics tracking during training.
python
typescript
curl
# create a fine-tuning job
created_jobs = client.fine_tuning.jobs.create(
    model="open-mistral-7b",
    training_files=[{"file_id": training_data.id, "weight": 1}],
    validation_files=[validation_data.id],
    hyperparameters={
        "training_steps": 10,
        "learning_rate":0.0001
    },
    auto_start=False,
#   integrations=[
#       {
#           "project": "finetuning",
#           "api_key": "WANDB_KEY",
#       }
#   ]
)

After creating a fine-tuning job, you can check the job status using client.fine_tuning.jobs.get(job_id = created_jobs.id).

Initially, the job status will be "QUEUED". After a brief period, the status will update to "VALIDATED". At this point, you can proceed to start the fine-tuning job:

python
typescript
curl
# start a fine-tuning job
client.fine_tuning.jobs.start(job_id = created_jobs.id)

created_jobs

List/retrieve/cancel jobs
You can also list jobs, retrieve a job, or cancel a job.

You can filter and view a list of jobs using various parameters such as page, page_size, model, created_after, created_by_me, status, wandb_project, wandb_name, and suffix. Check out our API specs for details.

python
typescript
curl
# List jobs
jobs = client.fine_tuning.jobs.list()
print(jobs)

# Retrieve a jobs
retrieved_jobs = client.fine_tuning.jobs.get(job_id = created_jobs.id)
print(retrieved_jobs)

# Cancel a jobs
canceled_jobs = client.fine_tuning.jobs.cancel(job_id = created_jobs.id)
print(canceled_jobs)

Use a fine-tuned model
When a fine-tuned job is finished, you will be able to see the fine-tuned model name via retrieved_jobs.fine_tuned_model. Then you can use our chat endpoint to chat with the fine-tuned model:

python
typescript
curl
chat_response = client.chat.complete(
    model=retrieved_job.fine_tuned_model,
    messages = [{"role":'user', "content":'What is the best French cheese?'}]
)

Delete a fine-tuned model
python
typescript
curl
client.models.delete(model_id=retrieved_job.fine_tuned_model)

FAQ
How to validate data format?
Mistral API: We currently validate each file when you upload the dataset.

mistral-finetune: You can run the data validation script to validate the data and run the reformat data script to reformat the data to the right format:

# download the reformat script
wget https://raw.githubusercontent.com/mistralai/mistral-finetune/main/utils/reformat_data.py
# download the validation script
wget https://raw.githubusercontent.com/mistralai/mistral-finetune/main/utils/validate_data.py
# reformat data
python reformat_data.py data.jsonl
# validate data
python validate_data.py data.jsonl

However, it's important to note that these scripts might not detect all problematic cases. Therefore, you may need to manually validate and correct any unique edge cases in your data.

What's the size limit of the training data?
While the size limit for an individual training data file is 512MB, there's no limitation on the number of files you can upload. You can upload multiple files and reference them when creating the job.

What's the size limit of the validation data?
The size limit for the validation data is 1MB. As a rule of thumb:

validation_set_max_size = min(1MB, 5% of training data)

What happens if I try to create a job that already exists?
At job creation, you will receive a 409 Conflict error in case a similar job is already running / validated / queued. This mechanism helps avoid inadvertently creating duplicate jobs, saving resources and preventing redundancy.

What if I upload an already existing file?
If a file is uploaded and matches an existing file in both content and name, the pre-existing file is returned instead of creating a new one.

How many epochs are in the training process?
A general rule of thumb is: Num epochs = max_steps / file_of_training_jsonls_in_MB. For instance, if your training file is 100MB and you set max_steps=1000, the training process will roughly perform 10 epochs.

Where can I find information on cost/ ETA / number of tokens / number of passes over each files?
Mistral API: When you create a fine-tuning job, you should automatically see these info with the default auto_start=False argument.

Note that the dry_run=True argument will be removed in September.

mistral-finetune: You can use the following script to find out: https://github.com/mistralai/mistral-finetune/blob/main/utils/validate_data.py. This script accepts a .yaml training file as input and returns the number of tokens the model is being trained on.

How to estimate cost of a fine-tuning job?
For Mistral API, you can use the auto_start=False argument as mentioned in the previous question.

What is the recommended learning rate?
For LoRA fine-tuning, we recommend 1e-4 (default) or 1e-5.

Note that the learning rate we define is the peak learning rate, instead of a flat learning rate. The learning rate follows a linear warmup and cosine decay schedule. During the warmup phase, the learning rate is linearly increased from a small initial value to a larger value over a certain number of training steps. After the warmup phase, the learning rate is decayed using a cosine function.

Is the fine-tuning API compatible with OpenAI data format?
Yes, we support OpenAI format.

What if my file size is larger than 500MB and I get the error message 413 Request Entity Too Large?
You can split your data file into chunks. Here is an example:

Details
Previous
Classifier Factory
Next
Batch Inference
Dataset Format
1. Default Instruct
2. Function-calling Instruct
Upload a file
Create a fine-tuning job
List/retrieve/cancel jobs
Use a fine-tuned model
Delete a fine-tuned model
FAQ
How to validate data format?
What's the size limit of the training data?
What's the size limit of the validation data?
What happens if I try to create a job that already exists?
What if I upload an already existing file?
How many epochs are in the training process?
Where can I find information on cost/ ETA / number of tokens / number of passes over each files?
How to estimate cost of a fine-tuning job?
What is the recommended learning rate?
Is the fine-tuning API compatible with OpenAI data format?
What if my file size is larger than 500MB and I get the error message 413 Request Entity Too Large?
Documentation
Documentation
Contributing
Community
Discord
X
GitHub
Copyright © 2025 Mistral AI.

Skip to main content
Mistral AI Logo
Le Chat
La Plateforme
Docs
API
GitHub
Discord

Search ⌘+K
Getting Started
Introduction
Quickstart
Models

Benchmarks
Model selection
Model weights
Clients
Model customization
Developer examples
Changelog
Glossary
Capabilities
Text and Chat Completions
Vision
Audio & Transcription
Reasoning
Document AI

Basic OCR
Annotations
Document QnA
Coding
Embeddings

Text Embeddings
Code Embeddings
Function calling
Citations and References
Structured Output

Custom
JSON mode
Moderation
Finetuning

Classifier Factory
Text & Vision Fine-tuning
Batch Inference
Predicted outputs
Agents
Introduction
Agents & Conversations
Connectors

MCP
Function Calling
Handoffs
Deployment
La Plateforme

Cloud

Self-deployment

Guides
Prompting capabilities
Basic RAG
Prefix
Tokenization
Sampling
Fine-tuning
Evaluation
Observability
Other resources
How to contribute

Batch Inference
Batch Inference
Prepare and upload your batch
A batch is composed of a list of API requests. The structure of an individual request includes:

A unique custom_id for identifying each request and referencing results after completion
A body object with message information
Here's an example of how to structure a batch request:

{"custom_id": "0", "body": {"max_tokens": 100, "messages": [{"role": "user", "content": "What is the best French cheese?"}]}}
{"custom_id": "1", "body": {"max_tokens": 100, "messages": [{"role": "user", "content": "What is the best French wine?"}]}}

Save your batch into a .jsonl file. Once saved, you can upload your batch input file to ensure it is correctly referenced when initiating batch processes:

python
typescript
curl
from mistralai import Mistral
import os

api_key = os.environ["MISTRAL_API_KEY"]

client = Mistral(api_key=api_key)

batch_data = client.files.upload(
    file={
        "file_name": "test.jsonl",
        "content": open("test.jsonl", "rb")
    },
    purpose = "batch"
)

Create a new batch job
Create a new batch job, it will be queued for processing.

input_files: a list of the batch input file IDs.
model: you can only use one model (e.g., codestral-latest) per batch. However, you can run multiple batches on the same files with different models if you want to compare outputs.
endpoint: we currently support /v1/embeddings, /v1/chat/completions, /v1/fim/completions, /v1/moderations, /v1/chat/moderations.
metadata: optional custom metadata for the batch.
python
typescript
curl
created_job = client.batch.jobs.create(
    input_files=[batch_data.id],
    model="mistral-small-latest",
    endpoint="/v1/chat/completions",
    metadata={"job_type": "testing"}
)

Get a batch job details
python
typescript
curl
retrieved_job = client.batch.jobs.get(job_id=created_job.id)

Get batch job results
python
typescript
curl
output_file_stream = client.files.download(file_id=retrieved_job.output_file)

# Write and save the file
with open('batch_results.jsonl', 'wb') as f:
    f.write(output_file_stream.read())

List batch jobs
You can view a list of your batch jobs and filter them by various criteria, including:

Status: QUEUED, RUNNING, SUCCESS, FAILED, TIMEOUT_EXCEEDED, CANCELLATION_REQUESTED and CANCELLED
Metadata: custom metadata key and value for the batch
python
typescript
curl
list_job = client.batch.jobs.list(
    status="RUNNING",
    metadata={"job_type": "testing"}
)

Request the cancellation of a batch job
python
typescript
curl
canceled_job = client.batch.jobs.cancel(job_id=created_job.id)

An end-to-end example
Example
FAQ
Is the batch API available for all models?
Yes, batch API is available for all models including user fine-tuned models.

Does the batch API affect pricing?
We offer a 50% discount on batch API. Learn more about our pricing.

Does the batch API affect rate limits?
No

What's the max number of requests in a batch?
Currently, there is a maximum limit of 1 million pending requests per workspace. This means you cannot submit a job with more than 1 million requests. Additionally, you cannot submit two jobs with 600,000 requests each at the same time. You would need to wait until the first job has processed at least 200,000 requests, reducing its pending count to 400,000. At that point, the new job with 600,000 requests would fit within the limit.

What's the max number of batch jobs one can create?
Currently, there is no maximum limit.

How long does the batch API take to process?
Processing speeds may be adjusted based on current demand and the volume of your request. Your batch results will only be accessible once the entire batch processing is complete.

Users can set timeout_hours when creating a job, which specifies the number of hours after which the job should expire. It defaults to 24 hours and should be lower than 7 days. A batch will expire if processing does not complete within the specified timeout.

Can I view batch results from my workspace?
Yes, batches are specific to a workspace. You can see all batches and their results that were created within the workspace associated with your API key.

Will batch results ever expire?
No, the results do not expire at this time.

Can batches exceed the spend limit?
Yes, due to high throughput and concurrent processing, batches may slightly exceed your workspace's configured spend limit.

Previous
Text & Vision Fine-tuning
Next
Predicted outputs
Prepare and upload your batch
Create a new batch job
Get a batch job details
Get batch job results
List batch jobs
Request the cancellation of a batch job
An end-to-end example
FAQ
Is the batch API available for all models?
Does the batch API affect pricing?
Does the batch API affect rate limits?
What's the max number of requests in a batch?
What's the max number of batch jobs one can create?
How long does the batch API take to process?
Can I view batch results from my workspace?
Will batch results ever expire?
Can batches exceed the spend limit?
Documentation
Documentation
Contributing
Community
Discord
X
GitHub
Copyright © 2025 Mistral AI


Skip to main content
Mistral AI Logo
Le Chat
La Plateforme
Docs
API
GitHub
Discord

Search ⌘+K
Getting Started
Introduction
Quickstart
Models

Benchmarks
Model selection
Model weights
Clients
Model customization
Developer examples
Changelog
Glossary
Capabilities
Text and Chat Completions
Vision
Audio & Transcription
Reasoning
Document AI

Basic OCR
Annotations
Document QnA
Coding
Embeddings

Text Embeddings
Code Embeddings
Function calling
Citations and References
Structured Output

Custom
JSON mode
Moderation
Finetuning

Classifier Factory
Text & Vision Fine-tuning
Batch Inference
Predicted outputs
Agents
Introduction
Agents & Conversations
Connectors

MCP
Function Calling
Handoffs
Deployment
La Plateforme

Cloud

Self-deployment

Guides
Prompting capabilities
Basic RAG
Prefix
Tokenization
Sampling
Fine-tuning
Evaluation
Observability
Other resources
How to contribute

Predicted outputs
Predicted outputs
Predicted Outputs optimizes response time by leveraging known or predictable content. This approach minimizes latency while maintaining high output quality. In tasks such as editing large texts, modifying code, or generating template-based responses, significant portions of the output are often predetermined. By predefining these expected parts with Predicted Outputs, models can allocate more computational resources to the unpredictable elements, improving overall efficiency.

Example: Code modification
Predicted Outputs shine in scenarios where you need to regenerate text documents or code files with minor modifications. The key parameter introduced is the prediction parameter, which enables users to define predicted outputs. For example, imagine you want your model to update the model used in a fine-tuning job. You can include the code snippet you'd like to modify as both the user prompt and the predicted output.

python
typescript
curl
import os
from mistralai import Mistral

api_key = os.environ["MISTRAL_API_KEY"]
model = "mistral-large-latest"

client = Mistral(api_key=api_key)

code = """
created_jobs = client.fine_tuning.jobs.create(
    model="open-mistral-7b", 
    training_files=[{"file_id": ultrachat_chunk_train.id, "weight": 1}],
    validation_files=[ultrachat_chunk_eval.id], 
    hyperparameters={
        "training_steps": 10,
        "learning_rate":0.0001
    },
    auto_start=False
)
"""

prompt = "Change the model name from open-mistral-7b to open-mistral-nemo. Respond only with code, no explanation, no formatting."

chat_response = client.chat.complete(
    model= model,
    messages = [
        {
            "role": "user",
            "content": prompt,
        },
        {
            "role": "user",
            "content": code
        },
    ],
    prediction = {
        "type": "content",
        "content": code
    }
)
print(chat_response.choices[0].message.content)

FAQ
Which model supports predicted outputs?
As of now, codestral-2501 and mistral-large-2411 support predicted outputs.

How does predicted outputs affect pricing?
Currently, predicted outputs do not impact pricing.

Which parameters are not supported when using Predicted Outputs?
n (number of completions to return for each request) is not supported when using predicted outputs.

Does the Position of Certain Sentences or Words in the Prediction Matter?
No, the placement of sentences or words in your prediction does not affect its effectiveness. Predictions can appear anywhere within the generated response and still help reduce the API's output latency.

Previous
Batch Inference
Next
Introduction
Example: Code modification
FAQ
Which model supports predicted outputs?
How does predicted outputs affect pricing?
Which parameters are not supported when using Predicted Outputs?
Does the Position of Certain Sentences or Words in the Prediction Matter?
Documentation
Documentation
Contributing
Community
Discord
X
GitHub
Copyright © 2025 Mistral AI..

Skip to main content
Mistral AI Logo
Le Chat
La Plateforme
Docs
API
GitHub
Discord

Search ⌘+K

Getting Started
Introduction
Quickstart
Models

Benchmarks
Model selection
Model weights
Clients
Model customization
Developer examples
Changelog
Glossary
Capabilities
Text and Chat Completions
Vision
Audio & Transcription
Reasoning
Document AI

Basic OCR
Annotations
Document QnA
Coding
Embeddings

Text Embeddings
Code Embeddings
Function calling
Citations and References
Structured Output

Custom
JSON mode
Moderation
Finetuning

Classifier Factory
Text & Vision Fine-tuning
Batch Inference
Predicted outputs
Agents
Introduction
Agents & Conversations
Connectors

MCP
Function Calling
Handoffs
Deployment
La Plateforme

Cloud

Self-deployment

Guides
Prompting capabilities
Basic RAG
Prefix
Tokenization
Sampling
Fine-tuning
Evaluation
Observability
Other resources
How to contribute

Fine-tuning
Fine-tuning
warning
There's a monthly storage fee of $2 for each model. For more detailed pricing information, please visit our pricing page.

Introduction
Fine-tuning is a powerful technique for customizing and optimizing the performance of large language models (LLMs) for specific use cases. By further training a pre-trained LLM on a labeled dataset related to a particular task, fine-tuning can improve the model's performance. This can be done with a large model for complex or dissimilar tasks, or with a smaller model to match the performance of a larger model, potentially leading to latency and cost benefits. The performance increase varies depending on the use cases.

Mistral AI provides a fine-tuning API through La Plateforme, making it easy to fine-tune all of our open-source and commercial models. For those interested in experimenting with different parameters and gaining a more in-depth understanding of the fine-tuning process, we also provide access to our open-source codebase mistral-finetune. However, we recommend using our API for all fine-tuning as it does not require GPUs, comes with various options, and also allows for the fine-tuning of our commercial models.

In this guide, we will cover the following topics:

Prepare the dataset
End-to-end examples with Mistral API
End-to-end examples with mistral-finetune
Prepare the dataset
Once you have chosen fine-tuning as the best approach for your specific use-case, the initial and most critical step is to gather and prepare training data for fine-tuning the models. Here are six specific use cases that you might find helpful:

Use cases
Use case 1: specific tone
Fine-tuning can be useful for establishing a particular tone in a conversation. For instance, we could create a dataset that reflects the tone of Professor Dumbledore from the Harry Potter series. A typical user/assistant exchange would look like this:

{
    "messages": [
        {
            "role": "user",
            "content": "How are you?"
        },
        {
            "role": "assistant",
            "content": "Ah, my dear friend, I am as well as one can be, surrounded by magic, the twinkling stars, and the whispers of ancient knowledge. Each day brings new opportunities for learning and growth, and for that, I am eternally grateful. How may I assist you on this fine day?"
        }
    ]
}

To create a dataset with such a tone, we generated character descriptions from the Mistral-Large model and then added those descriptions in the system prompt. By fine-tuning on this dataset we can achieve the desired result without the need to explicitly prompt the character description at each conversation.

from mistralai import Mistral
import os

api_key = os.environ.get("MISTRAL_API_KEY")

def run_mistral(sys_message, user_message, model="mistral-large-latest"):
    client = Mistral(api_key=api_key)
    messages = [
        {
            "role": "system",
            "content": sys_message
        },
        {
            "role": "user",
            "content": user_message
        }
    ]
    chat_response = client.chat.complete(
        model=model,
        messages=messages
    )
    return chat_response.choices[0].message.content

sys_message = """
    You are Albus Dumbledore. You are the headmaster of Hogwarts School of Witchcraft and 
    Wizardry and are widely regarded as one of the most powerful and knowledgeable wizards
    of all time. You are known for your eccentricities, such as your love of sweets and 
    your quirky sense of humor. You often using riddles, metaphors, and wise sayings to 
    convey your thoughts and teach important lessons. Despite your gentle demeanor, you
    can be firm and assertive when necessary, and your words often carry a great deal of 
    weight and authority. Respond succinctly in Dumbledore's distinctive tone.
"""
resp = run_mistral(sys_message, "How are you?")
print(resp)

Multi-turn

Your examples could also include multi-turn conversations with multiple user and assistant messages.

{
    "messages": [
        {
            "role": "user",
            "content": "How are you?"
        },
        {
            "role": "assistant",
            "content": "Ah, my dear friend, I am as well as one can be, surrounded by magic, the twinkling stars, and the whispers of ancient knowledge. Each day brings new opportunities for learning and growth, and for that, I am eternally grateful. How may I assist you on this fine day?"
        },
        {
            "role": "user",
            "content": "I'm concerned about Harry."
        },
        {
            "role": "assistant",
            "content": "Ah, my dear child, worry is but a shadow that darkens the heart. Yet, I understand your concern for young Harry. His journey is indeed fraught with challenges. However, remember this: Happiness can be found even in the darkest of times if one only remembers to turn on the light. Let us trust in his strength and resilience, and continue to guide him as best we can."
        }
    ]
}

Use case 2: specific format
Fine-tuning a model is beneficial for generating outputs in a specific format as it allows the model to learn the desired output format from a labeled dataset, which includes examples of the desired format. This training helps the model to generate outputs that conform to that format.

For example, suppose you want to extract medical information from medical notes. Let's use the medical_knowledge_from_extracts dataset where the desired output format is a JSON object with:

conditions,
interventions, which can be further categorized into behavioral, drugs and other types. An example of output would look like this:
{
    "conditions": "Proteinuria",
    "interventions": "Drug: Losartan Potassium|Other: Comparator: Placebo (Losartan)|Drug: Comparator: amlodipine besylate|Other: Comparator: Placebo (amlodipine besylate)|Other: Placebo (Losartan)|Drug: Enalapril Maleate"
}

Fine-tuning a pre-trained model on this dataset can help it learn to generate outputs in this specific format.

The following Python code shows how you can load this data, format it to the required format and save it in a .jsonl file. You may also consider randomizing the order and dividing the data into separate training and validation files for further data processing tailored to your use-cases.

import pandas as pd
import json

df = pd.read_csv(
    "https://huggingface.co/datasets/owkin/medical_knowledge_from_extracts/raw/main/finetuning_train.csv"
)

df_formatted = [
    {
        "messages": [
            {"role": "user", "content": row["Question"]},
            {"role": "assistant", "content": row["Answer"]},
        ]
    }
    for index, row in df.iterrows()
]

with open("data.jsonl", "w") as f:
    for line in df_formatted:
        json.dump(line, f)
        f.write("\n")


Here is an example of one instance of the data:

{
    "messages": [
        {
            "role": "user",
            "content": "Your goal is to extract structured information from the user's input that matches the form described below. When extracting information please make sure it matches the type information exactly...Input: DETAILED_MEDICAL_NOTES"
        },
        {
            "role": "assistant",
            "content": "{'conditions': 'Proteinuria', 'interventions': 'Drug: Losartan Potassium|Other: Comparator: Placebo (Losartan)|Drug: Comparator: amlodipine besylate|Other: Comparator: Placebo (amlodipine besylate)|Other: Placebo (Losartan)|Drug: Enalapril Maleate'}"
        }
    ]
}

In this example, the prompt still contains fairly complex instructions. We can fine-tune our model on the dataset without complex prompts. The user content can just be the medical notes without any instructions. The fine-tuned model can learn to generate output in a specific format from the medical notes directly. Let's only use the medical notes as the user message:

import pandas as pd
import json

df = pd.read_csv(
    "https://huggingface.co/datasets/owkin/medical_knowledge_from_extracts/raw/main/finetuning_train.csv"
)

df_formatted = [
    {
        "messages": [
            {"role": "user", "content": row["Question"].split("Input:")[1]},
            {"role": "assistant", "content": row["Answer"]},
        ]
    }
    for index, row in df.iterrows()
]

with open("data.jsonl", "w") as f:
    for line in df_formatted:
        json.dump(line, f)
        f.write("\n")


Here is an example of one instance of the data:

{
    "messages": [
        {
            "role": "user",
            "content": "DETAILED_MEDICAL_NOTES"
        },
        {
            "role": "assistant",
            "content": "{'conditions': 'Proteinuria', 'interventions': 'Drug: Losartan Potassium|Other: Comparator: Placebo (Losartan)|Drug: Comparator: amlodipine besylate|Other: Comparator: Placebo (amlodipine besylate)|Other: Placebo (Losartan)|Drug: Enalapril Maleate'}"
        }
    ]
}

Use case 3: specific style
You can fine-tune for specific styles. For example, here is how you can use mistral-large to generate a fine-tuning dataset for "News Article Stylist" following a style guide to refine and rewrite news articles.

The process is simple. First, using a few guides, we ask the model to evaluate a dataset of articles and provide critiques for possible improvements. Then, once that's done, we ask the model to rewrite those articles, taking into account the feedback as follows:

def process_refined_news(args):
    line, system, instruction = args
    record = json.loads(line)

    news_article = record.get("news")
    critique= record.get("critique")
    status = record.get("status")

    time.sleep(1)

    try:
    if status == "SUCCESS":

        answer = CLIENT.chat.complete(
            model="mistral-large-latest",
            messages= [
                {"role": "system", "content": system},
                {"role": "user", "content": news_article},
                {"role": "assistant", "content": critique},
                {"role": "user", "content": instruction},
            ],
            temperature=0.2,
            max_tokens=2048
        )
        new_news = answer.choices[0].message.content

        result = json.dumps({"news": news_article, "critique": critique, "refined_news": new_news, "status": "SUCCESS"})

    else:
        result = json.dumps({"news": news_article, "critique": critique, "refined_news": critique, "status": "ERROR"})
    except Exception as e:
        result = json.dumps({"news": news_article, "critique": critique, "refined_news": str(e), "status": "ERROR"})

    random_hash = secrets.token_hex(4)

    with open(f"./data/refined_news_{random_hash}.jsonl", "w") as f:
        f.write(result)

    return result

system = "Polish and restructure the news articles to align them with the high standards of clarity, accuracy, and elegance set by the style guide. You are presented with a news article. Identify the ten (or fewer) most significant stylistic concerns and provide examples of how they can be enhanced."

instruction = """
Now, I want you to incorporate the feedback and critiques into the news article and respond with the enhanced version, focusing solely on stylistic improvements without altering the content.
You must provide the entire article enhanced.
Do not make ANY comments, only provide the new article improved.
Do not tell me what you changed, only provide the new article taking into consideration the feedback you provided.
The new article needs to have all the content of the original article but with the feedback into account.
"""

data_path = "./generated_news_critiques.jsonl"
with open(data_path, "r") as f:
    lines = f.readlines()
    lines = [(line, system, instruction) for line in lines]

    results = process_map(process_refined_news, lines, max_workers=20, chunksize=1)

with open("./generated_refined_news.jsonl", "w") as f:
    for result in results:
        f.write(result + "\n")

The full notebook can be found here:

Open In Colab
Use case 4: coding
Fine-tuning is a highly-effective method for customizing a pre-trained model to a specific domain task such as generating SQL queries from natural language text. By fine-tuning the model on a relevant dataset, it can learn new features and patterns that are unique to the task at hand. For instance, in the case of text-to-SQL integration, we can use the sql-create-context which contains SQL questions along with the context of the SQL table, to train the model to output the correct SQL syntax.

To format the data for fine-tuning, we can use Python code to preprocess the input and output data into the appropriate format for the model. Here is an example of how to format the data for text-to-SQL generation:

import pandas as pd
import json

df = pd.read_json(
    "https://huggingface.co/datasets/b-mc2/sql-create-context/resolve/main/sql_create_context_v4.json"
)

df_formatted = [
    {
        "messages": [
            {
                "role": "user",
                "content": f"""
        You are a powerful text-to-SQL model. Your job is to answer questions about a database. You are given a question and context regarding one or more tables. 

        You must output the SQL query that answers the question.
        
        ### Input:
        {row["question"]}
        
        ### Context:
        {row["context"]}
        
        ### Response:
        """,
            },
            {"role": "assistant", "content": row["answer"]},
        ]
    }
    for index, row in df.iterrows()
]

with open("data.jsonl", "w") as f:
    for line in df_formatted:
        json.dump(line, f)
        f.write("\n")

Here is an example of the formatted data:

{
  "messages": [
    {
      "role": "user",
      "content": "\n        You are a powerful text-to-SQL model. Your job is to answer questions about a database. You are given a question and context regarding one or more tables. \n\n        You must output the SQL query that answers the question.\n        \n        ### Input:\n        How many heads of the departments are older than 56 ?\n        \n        ### Context:\n        CREATE TABLE head (age INTEGER)\n        \n        ### Response:\n        "
    },
    {
      "role": "assistant",
      "content": "SELECT COUNT(*) FROM head WHERE age > 56"
    }
  ]
}

Use case 5: domain-specific augmentation in RAG
Fine-tuning can improve Q&A performance in a standard RAG workflow. For example, this study demonstrated higher performance in RAG by employing a fine-tuned embedding model and a fine-tuned LLM. Another research introduced Retrieval Augmented Fine-Tuning (RAFT), a method that fine-tunes an LLM to not only answer questions based on the relevant documents but also to ignore irrelevant documents, resulting in substantial improvement in RAG performance across all specialized domains.

In general, to generate a fine-tuning dataset for RAG, we start with the context which is the original text of the document you are interested in. Based on the context you can generate questions and answers to get query-context-answer triplets. Here are two prompt templates for generating questions and answers:

Prompt template for generating questions based on the context:

Context information is below.
---------------------
{context_str}
---------------------
Given the context information and not prior knowledge. Generate {num_questions_per_chunk}
questions based on the context. The questions should be diverse in nature across the
document. Restrict the questions to the context information provided.

Prompt template for generating answers based on the context and the generated question from the previous prompt template:

Context information is below
---------------------
{context_str}
---------------------
Given the context information and not prior knowledge,
answer the query.
Query: {generated_query_str}
Answer: 

Use case 6: knowledge transfer
One of the significant use-cases of fine-tuning is knowledge distillation for a larger model. Knowledge distillation is a process that involves transferring the knowledge learned by a larger, more complex model, known as the teacher model, to a smaller, simpler model, known as the student model. Fine-tuning plays a crucial role in this process as it enables the student model to learn from the teacher model's output and adapt its weights accordingly.

Assume we have some medical notes data that requires labelling. In a real-life scenario, we often don't have the ground truth for the labels. For instance, let's consider the medical notes from the medical_knowledge_from_extracts dataset that we used in Use-case 2. Let's assume we don't have the verified truth for the labels. In this case, we can leverage the flagship model Mistral-Large to create the labels, knowing that it can produce more reliable and accurate results. Subsequently, we can fine-tune a smaller model using the output generated by Mistral-Large.

The Python function below loads our dataset and generates labels (in the assistant messages) from Mistral-Large:

from mistralai import Mistral
import pandas as pd
import json
import os

api_key = os.environ.get("MISTRAL_API_KEY")

def run_mistral(user_message, model="mistral-large-latest"):
    client = Mistral(api_key=api_key)
    messages = [
        {
            "role": "user",
            "content": user_message
        }
    ]
    chat_response = client.chat.complete(
        model=model, response_format={"type": "json_object"}, messages=messages
    )
    return chat_response.choices[0].message.content


# load dataset and select top 10 rows as an example
df = pd.read_csv(
    "https://huggingface.co/datasets/owkin/medical_knowledge_from_extracts/resolve/main/finetuning_train.csv"
).head(10)

# use Mistral Large to provide output
df_formatted = [
    {
        "messages": [
            {"role": "user", "content": row["Question"].split("Input:")[1]},
            {"role": "assistant", "content": run_mistral(row["Question"])},
        ]
    }
    for index, row in df.iterrows()
]

with open("data.jsonl", "w") as f:
    for line in df_formatted:
        json.dump(line, f)
        f.write("\n")


Here is an example of one instance of the data:

{
  "messages": [
    {
      "role": "user",
      "content": "Randomized trial of the effect of an integrative medicine approach to the management of asthma in adults on disease-related quality of life and pulmonary function.  The purpose of this study was to test the effectiveness of an integrative medicine approach to the management of asthma compared to standard clinical care on quality of life (QOL) and clinical outcomes. This was a prospective parallel group repeated measurement randomized design. Participants were adults aged 18 to 80 years with asthma. The intervention consisted of six group sessions on the use of nutritional manipulation, yoga techniques, and journaling. Participants also received nutritional supplements: fish oil, vitamin C, and a standardized hops extract. The control group received usual care. Primary outcome measures were the Asthma Quality of Life Questionnaire (AQLQ), The Medical Outcomes Study Short Form-12 (SF-12), and standard pulmonary function tests (PFTs). In total, 154 patients were randomized and included in the intention-to-treat analysis (77 control, 77 treatment). Treatment participants showed greater improvement than controls at 6 months for the AQLQ total score (P<.001) and for three subscales, Activity (P< 0.001), Symptoms (P= .02), and Emotion (P<.001). Treatment participants also showed greater improvement than controls on three of the SF-12 subscales, Physical functioning (P=.003); Role limitations, Physical (P< .001); and Social functioning (P= 0.03), as well as in the aggregate scores for Physical and Mental health (P= .003 and .02, respectively). There was no change in PFTs in either group. A low-cost group-oriented integrative medicine intervention can lead to significant improvement in QOL in adults with asthma. Output:"
    },
    {
      "role": "assistant",
      "content": "{\"conditions\": \"asthma\", \"drug_or_intervention\": \"integrative medicine approach with nutritional manipulation, yoga techniques, journaling, fish oil, vitamin C, and a standardized hops extract\"}"
    }
  ]
}

Use case 7: agents for function calling
Fine-tuning plays a pivotal role in shaping the reasoning and decision-making process of agents, when it comes to determining which actions to take and which tools to use. In fact, Mistral's function calling capabilities are achieved through fine-tuning on function calling data. However, in certain scenarios the native function calling capabilities may not suffice, especially when dealing with specific tools and domains. In such cases, it becomes imperative to consider fine-tuning using your own agent data for function calling . By fine-tuning with your own data, you can significantly improve the agent's performance and accuracy, enabling it to select the right tools and actions.

Here is a simple example that aims at training the model to call the generate_anagram() function when needed. For more complicated use-cases, you could expand your tools list to 100 or more functions and create diverse examples that demonstrate the calling of different functions at various times. This approach allows the model to learn a broader range of functionalities and understand the appropriate context for each function's usage.

{
    "messages": [
        {
            "role": "system",
            "content": "You are a helpful assistant with access to the following functions to help the user. You can use the functions if needed."
        },
        {
            "role": "user",
            "content": "Can you help me generate an anagram of the word 'listen'?"
        },
        {
            "role": "assistant",
            "tool_calls": [
                {
                    "id": "TX92Jm8Zi",
                    "type": "function",
                    "function": {
                        "name": "generate_anagram",
                        "arguments": "{\"word\": \"listen\"}"
                    }
                }
            ]
        },
        {
            "role": "tool",
            "content": "{\"anagram\": \"silent\"}",
            "tool_call_id": "TX92Jm8Zi"
        },
        {
            "role": "assistant",
            "content": "The anagram of the word 'listen' is 'silent'."
        },
        {
            "role": "user",
            "content": "That's amazing! Can you generate an anagram for the word 'race'?"
        },
        {
            "role": "assistant",
            "tool_calls": [
                {
                    "id": "3XhQnxLsT",
                    "type": "function",
                    "function": {
                        "name": "generate_anagram",
                        "arguments": "{\"word\": \"race\"}"
                    }
                }
            ]
        }
    ],
    "tools": [
        {
            "type": "function",
            "function": {
                "name": "generate_anagram",
                "description": "Generate an anagram of a given word",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "word": {
                            "type": "string",
                            "description": "The word to generate an anagram of"
                        }
                    },
                    "required": ["word"]
                }
            }
        }
    ]
}

End-to-end example with Mistral API
Open In Colab
You can fine-tune all Mistral’s models via Mistral API. Follow the steps below using Mistral's fine-tuning API.

Prepare dataset
In this example, let’s use the ultrachat_200k dataset. We load a chunk of the data into Pandas Dataframes, split the data into training and validation, and save the data into the required jsonl format for fine-tuning.

import pandas as pd
df = pd.read_parquet('https://huggingface.co/datasets/HuggingFaceH4/ultrachat_200k/resolve/main/data/test_gen-00000-of-00001-3d4cd8309148a71f.parquet')

df_train=df.sample(frac=0.995,random_state=200)
df_eval=df.drop(df_train.index)

df_train.to_json("ultrachat_chunk_train.jsonl", orient="records", lines=True)
df_eval.to_json("ultrachat_chunk_eval.jsonl", orient="records", lines=True)


Reformat dataset
If you upload this ultrachat_chunk_train.jsonl to Mistral API, you might encounter an error message “Invalid file format” due to data formatting issues. To reformat the data into the correct format, you can download the reformat_data.py script and use it to validate and reformat both the training and evaluation data:

# download the validation and reformat script 
wget https://raw.githubusercontent.com/mistralai/mistral-finetune/main/utils/reformat_data.py

# validate and reformat the training data
python reformat_data.py ultrachat_chunk_train.jsonl

# validate the reformat the eval data 
python reformat_data.py ultrachat_chunk_eval.jsonl

important
This reformat_data.py script is tailored for the UltraChat data and may not be universally applicable to other datasets. Please modify this script and reformat your data accordingly.

After running the script, few cases were removed from the training data.

Skip 3674th sample
Skip 9176th sample
Skip 10559th sample
Skip 13293th sample
Skip 13973th sample
Skip 15219th sample

Let’s inspect one of these cases. There are two issues with this use case:

one of the assistant messages is an empty string;
the last message is not an assistant message.
drawing
Upload dataset
We can then upload both the training data and evaluation data to the Mistral Client, making them available for use in fine-tuning jobs.

python
typescript
curl
from mistralai import Mistral
import os

api_key = os.environ["MISTRAL_API_KEY"]

client = Mistral(api_key=api_key)

ultrachat_chunk_train = client.files.upload(file={
    "file_name": "ultrachat_chunk_train.jsonl",
    "content": open("ultrachat_chunk_train.jsonl", "rb"),
})
ultrachat_chunk_eval = client.files.upload(file={
    "file_name": "ultrachat_chunk_eval.jsonl",
    "content": open("ultrachat_chunk_eval.jsonl", "rb"),
})

Example output:

Note that you will need the file IDs for the next steps.

{
    "id": "66f96d02-8b51-4c76-a5ac-a78e28b2584f",
    "object": "file",
    "bytes": 140893645,
    "created_at": 1717164199,
    "filename": "ultrachat_chunk_train.jsonl",
    "purpose": "fine-tune"
}

{
    "id": "84482011-dfe9-4245-9103-d28b6aef30d4",
    "object": "file",
    "bytes": 7247934,
    "created_at": 1717164200,
    "filename": "ultrachat_chunk_eval.jsonl",
    "purpose": "fine-tune"
}

Create a fine-tuning job
Next, we can create a fine-tuning job:

python
typescript
curl
# create a fine-tuning job
created_jobs = client.fine_tuning.jobs.create(
    model="open-mistral-7b", 
    training_files=[{"file_id": ultrachat_chunk_train.id, "weight": 1}],
    validation_files=[ultrachat_chunk_eval.id], 
    hyperparameters={
        "training_steps": 10,
        "learning_rate":0.0001
    },
    auto_start=False
)

# start a fine-tuning job
client.fine_tuning.jobs.start(job_id = created_jobs.id)

created_jobs

Example output:

{
    "id": "25d7efe6-6303-474f-9739-21fb0fccd469",
    "hyperparameters": {
        "training_steps": 10,
        "learning_rate": 0.0001
    },
    "fine_tuned_model": null,
    "model": "open-mistral-7b",
    "status": "QUEUED",
    "job_type": "FT",
    "created_at": 1717170356,
    "modified_at": 1717170357,
    "training_files": [
        "66f96d02-8b51-4c76-a5ac-a78e28b2584f"
    ],
    "validation_files": [
        "84482011-dfe9-4245-9103-d28b6aef30d4"
    ],
    "object": "job",
    "integrations": []
}

Analyze and evaluate fine-tuned model
When we retrieve a model, we get the following metrics every 10% of the progress with a minimum of 10 steps in between:

Training loss: the error of the model on the training data, indicating how well the model is learning from the training set.
Validation loss: the error of the model on the validation data, providing insight into how well the model is generalizing to unseen data.
Validation token accuracy: the percentage of tokens in the validation set that are correctly predicted by the model.
Both validation loss and validation token accuracy serve as essential indicators of the model's overall performance, helping to assess its ability to generalize and make accurate predictions on new data.

python
typescript
curl
# Retrieve a jobs
retrieved_jobs = client.fine_tuning.jobs.get(job_id = created_jobs.id)
print(retrieved_jobs)

Example output when we run 100 steps:
Use a fine-tuned model
When a fine-tuned job is finished, you will be able to see the fine-tuned model name via retrieved_jobs.fine_tuned_model. Then you can use our chat endpoint to chat with the fine-tuned model:

python
typescript
curl
chat_response = client.chat.complete(
    model = retrieved_jobs.fine_tuned_model,
    messages = [{"role":'user', "content":'What is the best French cheese?'}]
)

Integration with Weights and Biases
We can also offer support for integration with Weights & Biases (W&B) to monitor and track various metrics and statistics associated with our fine-tuning jobs. To enable integration with W&B, you will need to create an account with W&B and add your W&B information in the “integrations” section in the job creation request:

client.fine_tuning.jobs.create(
    model="open-mistral-7b", 
    training_files=[{"file_id": ultrachat_chunk_train.id, "weight": 1}],
    validation_files=[ultrachat_chunk_eval.id],
    hyperparameters={"training_steps": 10, "learning_rate": 0.0001},
    integrations=[
        {
            "project": "<value>",
            "api_key": "<value>",
        }
    ]
)

Here are the screenshots of the W&B dashboard showing the information of our fine-tuning job.

drawing
End-to-end example with open-source mistral-finetune
We have also open sourced fine-tuning codebase mistral-finetune allowing you to fine-tune Mistral’s open-weights models (Mistral 7B, Mixtral 8x7B, Mixtral 8x22B).

To see an end-to-end example of how to install mistral-finetune, prepare and validate your dataset, define your training configuration, fine-tune using Mistral-LoRA, and run inference, please refer to the README file provided in the Mistral-finetune repo: https://github.com/mistralai/mistral-finetune/tree/main or follow this example:

Open In Colab
Previous
Sampling
Next
Evaluation
Introduction
Prepare the dataset
Use cases
End-to-end example with Mistral API
Prepare dataset
Reformat dataset
Upload dataset
Create a fine-tuning job
Analyze and evaluate fine-tuned model
Use a fine-tuned model
Integration with Weights and Biases
End-to-end example with open-source mistral-finetune
Documentation
Documentation
Contributing
Community
Discord
X
GitHub
Copyright © 2025 Mistral AI.


Skip to main content
Mistral AI Logo
Le Chat
La Plateforme
Docs
API
GitHub
Discord

Search ⌘+K
Getting Started
Introduction
Quickstart
Models

Benchmarks
Model selection
Model weights
Clients
Model customization
Developer examples
Changelog
Glossary
Capabilities
Text and Chat Completions
Vision
Audio & Transcription
Reasoning
Document AI

Basic OCR
Annotations
Document QnA
Coding
Embeddings

Text Embeddings
Code Embeddings
Function calling
Citations and References
Structured Output

Custom
JSON mode
Moderation
Finetuning

Classifier Factory
Text & Vision Fine-tuning
Batch Inference
Predicted outputs
Agents
Introduction
Agents & Conversations
Connectors

MCP
Function Calling
Handoffs
Deployment
La Plateforme

Cloud

Self-deployment

Guides
Prompting capabilities
Basic RAG
Prefix
Tokenization
Sampling
Fine-tuning
Evaluation
Observability
Other resources
How to contribute

Tokenization
Tokenization
Open In Colab
Tokenization is a fundamental step in LLMs. It is the process of breaking down text into smaller subword units, known as tokens. We recently open-sourced our tokenizer at Mistral AI. This guide will walk you through the fundamentals of tokenization, details about our open-source tokenizers, and how to use our tokenizers in Python.

What is tokenization?
Tokenization is the first step and the last step of text processing and modeling. Texts need to be represented as numbers in our models so that our model can understand. Tokenization breaks down text into tokens, and each token is assigned a numerical representation, or index, which can be used to feed into a model. In a typical LLM workflow:

We first encode the input text into tokens using a tokenizer. Each unique token is assigned a specific index number in the tokenizer’s vocabulary.
Once the text is tokenized, these tokens are passed through the model, which typically includes an embedding layer and transformer blocks. The embedding layer converts the tokens into dense vectors that capture semantic meanings. Check out our embedding guide for details. The transformer blocks then process these embedding vectors to understand the context and generate results.
The last step is decoding, which detokenize output tokens back to human-readable text. This is done by mapping the tokens back to their corresponding words using the tokenizer’s vocabulary.
drawing
Most people only tokenize text. Our first release contains tokenization. Our tokenizers go beyond the usual text <-> tokens, adding parsing of tools and structured conversation. We also release the validation and normalization code that is used in our API. Specifically, we use control tokens, which are special tokens to indicate different types of elements. These tokens are not treated as strings and are added directly to the code. Note that we are still iterating on the tokenizer. Things may change and this is the current state of things.

We have released three versions of our tokenizers powering different sets of models.

v1: mistral-embed, open-mixtral-8x7b
v2: mistral-small-2402 (deprecated), mistral-large-2402
v3: open-mixtral-8x22b, mistral-large-latest, mistral-small-latest, open-mistral-7b
v3 (tekken): open-mistral-nemo, ministral-8b-latest
This guide will focus on our latest v3 (tekken) tokenizer and v3 tokenizer.

v3 (tekken) tokenizer
There are several tokenization methods used in Natural Language Processing (NLP) to convert raw text into tokens such as word-level tokenization, character-level tokenization, and subword-level tokenization including the Byte-Pair Encoding (BPE). Our newest tokenizer, tekken, uses the Byte-Pair Encoding (BPE) with Tiktoken.

Tekken was trained on more than 100 languages and compresses natural language text and source code more efficiently than the SentencePiece tokeniser used in previous Mistral models. In particular, it is ~30% more efficient at compressing source code in Chinese, Italian, French, German, Spanish, and Russian. It is also 2x and 3x more efficient at compressing Korean and Arabic, respectively. Compared to the Llama 3 tokeniser, Tekken proved more proficient in compressing text for approximately 85% of all languages.

drawing
Our tokenization vocabulary
Our tokenization vocabulary is released in the https://github.com/mistralai/mistral-common/tree/main/tests/data folder. Let’s take a look at the vocabulary of our v3 tekken tokenizer.

Vocabulary size
Our vocabulary consists of 130k vocab + 1k control tokens.

Control tokens
Our vocabulary starts with 14 control tokens, which are special tokens we use in the encoding process to represent specific instructions or indicators:

<unk>
<s>
</s>
[INST]
[/INST]
[AVAILABLE_TOOLS]
[/AVAILABLE_TOOLS]
[TOOL_RESULTS]
[/TOOL_RESULTS]
[TOOL_CALLS]
<pad>
[PREFIX]
[MIDDLE]
[SUFFIX]

The tokenizer does not encode control tokens, which help prevent a situation known as prompt injection. For example, the control token “[INST]” is used to denote user message:

Without the control tokens, the tokenizer treats “[INST]” as a regular string and encodes the entire sequence “[INST] I love Paris [/INST]”. This could potentially allow users to include "[INST]" and "[/INST]" tags within their message, causing confusion for the model as it might interpret part of the user's message as an assistant's message.
With the control tokens, the tokenizer instead concatenates the control tokens with the encoded message: [INST] + encode(“I love Paris”) + [/INST]. This ensures that only the user's message gets encoded, and the encoded messages are guaranteed to have the correct [INST] and [/INST] tags.
You may have noticed that we have 1000 slots for control tokens. The remaining 1000-14=986 slots for control tokens are actually empty for us to add more control tokens in the future and also ensure our vocabulary size is 131k (2^17). Computers like powers of 2s!

Bytes, characters, and merged characters
Below are two examples of the vocab. token_str is null when the byte sequence doesn't decode into a full unicode character, e.g., raw bytes.

{
    "rank": 0,
    "token_bytes": "AA==",
    "token_str": "\u0000"
},
...
{
    "rank": 7613,
    "token_bytes": "IO2D",
    "token_str": null
},

Run our tokenizer in Python
To get started, let’s first install our tokenizer and tiktoken via pip install mistral-common tiktoken.

Once the tokenizer is installed, in a Python environment, we can import the needed modules from mistral_common.

from mistral_common.protocol.instruct.messages import (
    UserMessage,
)
from mistral_common.protocol.instruct.request import ChatCompletionRequest
from mistral_common.protocol.instruct.tool_calls import (
    Function,
    Tool,
)
from mistral_common.tokens.tokenizers.mistral import MistralTokenizer

We then can load our tokenizer.

tokenizer = MistralTokenizer.v3(is_tekken=True)
model_name = "nemostral"
tokenizer = MistralTokenizer.from_model(model_name)

Let’s tokenize a series of conversation with different types of messages.

# Tokenize a list of messages
tokenized = tokenizer.encode_chat_completion(
    ChatCompletionRequest(
        tools=[
            Tool(
                function=Function(
                    name="get_current_weather",
                    description="Get the current weather",
                    parameters={
                        "type": "object",
                        "properties": {
                            "location": {
                                "type": "string",
                                "description": "The city and state, e.g. San Francisco, CA",
                            },
                            "format": {
                                "type": "string",
                                "enum": ["celsius", "fahrenheit"],
                                "description": "The temperature unit to use. Infer this from the users location.",
                            },
                        },
                        "required": ["location", "format"],
                    },
                )
            )
        ],
        messages=[
            UserMessage(content="What's the weather like today in Paris"),
        ],
        model=model_name,
    )
)
tokens, text = tokenized.tokens, tokenized.text


Here is the output of “text”, which is a debug representation for you to inspect.

<s>[AVAILABLE_TOOLS][{"type": "function", "function": {"name": "get_current_weather", "description": "Get the current weather", "parameters": {"type": "object", "properties": {"location": {"type": "string", "description": "The city and state, e.g. San Francisco, CA"}, "format": {"type": "string", "enum": ["celsius", "fahrenheit"], "description": "The temperature unit to use. Infer this from the users location."}}, "required": ["location", "format"]}}}][/AVAILABLE_TOOLS][INST]What's the weather like today in Paris[/INST]

To count the number of tokens, run len(tokens) and we get 128 tokens.

v3 tokenizer
Our v3 tokenizer uses the Byte-Pair Encoding (BPE) with SentencePiece, which is an open-source tokenization library to build our tokenization vocabulary.

In BPE, the tokenization process starts by treating each byte in a text as a separate token. Then, it iteratively adds new tokens to the vocabulary for the most frequent pair of tokens currently appearing in the corpus. For example, if the most frequent pair of tokens is "th" + "e", then a new token "the" will be created and occurrences of "th"+"e" will be replaced with the new token "the". This process continues until no more replacements can be made.

Our tokenization vocabulary
Our tokenization vocabulary is released in the https://github.com/mistralai/mistral-common/tree/main/tests/data folder. Let’s take a look at the vocabulary of our v3 tokenizer.

Vocabulary size
Our vocabulary consists of 32k vocab + 768 control tokens. The 32k vocab includes 256 bytes and 31,744 characters and merged characters.

Control tokens
Our vocabulary starts with 10 control tokens, which are special tokens we use in the encoding process to represent specific instructions or indicators:

<unk>
<s>
</s>
[INST]
[/INST]
[TOOL_CALLS]
[AVAILABLE_TOOLS]
[/AVAILABLE_TOOLS]
[TOOL_RESULTS]
[/TOOL_RESULTS]

Bytes
After the control token slots, we have 256 bytes in the vocabulary. A byte is a unit of digital information that consists of 8 bits. Each bit can represent one of two values, either 0 or 1. A byte can therefore represent 256 different values.

<0x00>
<0x01>
...

Any character, regardless of the language or symbol, can be represented by a sequence of one or more bytes. When a word is not present in the vocabulary, it can still be represented by the bytes that correspond to its individual characters. This is important for handling unknown words and characters.

Characters and merged characters
And finally, we have the characters and merged characters in the vocabulary. The order of the tokens are determined by the frequency of these tokens in the data that was used to train the model, with the most frequent ones in the beginning of the vocabulary. For example, two spaces “▁”, four spaces “▁▁▁▁”, “_t”, “in”, and “er” were found to be the most common tokens we trained on. As we move further down the vocabulary list, the tokens become less frequent. Towards the end of the vocabulary file, you might find less common characters such as Chinese and Korean characters. These characters are less frequent because they were encountered less often in the training data, not because they are less used in general.

▁▁
▁▁▁▁
▁t
in
er
...
벨
ゼ
梦

Run our tokenizer in Python
To get started, let’s first install our tokenizer via pip install mistral-common.

Once the tokenizer is installed, in a Python environment, we can import the needed modules from mistral_common.

from mistral_common.protocol.instruct.messages import (
    AssistantMessage,
    UserMessage,
    ToolMessage
)
from mistral_common.tokens.tokenizers.mistral import MistralTokenizer
from mistral_common.protocol.instruct.tool_calls import Function, Tool, ToolCall, FunctionCall
from mistral_common.protocol.instruct.request import ChatCompletionRequest

We load our tokenizer with MistralTokenizer and specify which version of tokenizer we’d like to load.

tokenizer_v3 = MistralTokenizer.v3()

Let’s tokenize a series of conversation with different types of messages

tokenized = tokenizer_v3.encode_chat_completion(
    ChatCompletionRequest(
        tools=[
            Tool(
                function=Function(
                    name="get_current_weather",
                    description="Get the current weather",
                    parameters={
                        "type": "object",
                        "properties": {
                            "location": {
                                "type": "string",
                                "description": "The city and state, e.g. San Francisco, CA",
                            },
                            "format": {
                                "type": "string",
                                "enum": ["celsius", "fahrenheit"],
                                "description": "The temperature unit to use. Infer this from the users location.",
                            },
                        },
                        "required": ["location", "format"],
                    },
                )
            )
        ],
        messages=[
            UserMessage(content="What's the weather like today in Paris"),
            AssistantMessage(
                content=None,
                tool_calls=[
                    ToolCall(
                        id="VvvODy9mT",
                        function=FunctionCall(
                            name="get_current_weather",
                            arguments='{"location": "Paris, France", "format": "celsius"}',
                        ),
                    )
                ],
            ),
            ToolMessage(
                tool_call_id="VvvODy9mT", name="get_current_weather", content="22"
            ),
            AssistantMessage(
                content="The current temperature in Paris, France is 22 degrees Celsius.",
            ),
            UserMessage(content="What's the weather like today in San Francisco"),
            AssistantMessage(
                content=None,
                tool_calls=[
                    ToolCall(
                        id="fAnpW3TEV",
                        function=FunctionCall(
                            name="get_current_weather",
                            arguments='{"location": "San Francisco", "format": "celsius"}',
                        ),
                    )
                ],
            ),
            ToolMessage(
                tool_call_id="fAnpW3TEV", name="get_current_weather", content="20"
            ),
        ],
        model="test",
    )
)

tokens, text = tokenized.tokens, tokenized.text

Here is the output of “text”, which is a debug representation for you to inspect.

'<s>[INST] What\'s the weather like today in Paris[/INST][TOOL_CALLS] [{"name": "get_current_weather", "arguments": {"location": "Paris, France", "format": "celsius"}, "id": "VvvODy9mT"}]</s>[TOOL_RESULTS] {"call_id": "VvvODy9mT", "content": 22}[/TOOL_RESULTS] The current temperature in Paris, France is 22 degrees Celsius.</s>[AVAILABLE_TOOLS] [{"type": "function", "function": {"name": "get_current_weather", "description": "Get the current weather", "parameters": {"type": "object", "properties": {"location": {"type": "string", "description": "The city and state, e.g. San Francisco, CA"}, "format": {"type": "string", "enum": ["celsius", "fahrenheit"], "description": "The temperature unit to use. Infer this from the users location."}}, "required": ["location", "format"]}}}][/AVAILABLE_TOOLS][INST] What\'s the weather like today in San Francisco[/INST][TOOL_CALLS] [{"name": "get_current_weather", "arguments": {"location": "San Francisco", "format": "celsius"}, "id": "fAnpW3TEV"}]</s>[TOOL_RESULTS] {"call_id": "fAnpW3TEV", "content": 20}[/TOOL_RESULTS]'

To count the number of tokens, run len(tokens) and we get 302 tokens.

Use cases
NLP tasks
As we mentioned earlier, tokenization is a crucial first step in natural language processing (NLP) tasks. Once we have tokenized our text, we can use those tokens to create text embeddings, which are dense vector representations of the text. These embeddings can then be used for a variety of NLP tasks, such as text classification, sentiment analysis, and machine translation.

Mistral's embedding API simplifies this process by combining the tokenization and embedding steps into one. With this API, we can easily create text embeddings for a given text, without having to separately tokenize the text and create embeddings from the tokens.

If you're interested in learning more about how to use Mistral's embedding API, be sure to check out our embedding guide, which provides detailed instructions and examples.

Tokens count
Mistral AI's LLM API endpoints charge based on the number of tokens in the input text.

To help you estimate your costs, our tokenization API makes it easy to count the number of tokens in your text. Simply run len(tokens) as shown in the example above to get the total number of tokens in the text, which you can then use to estimate your cost based on our pricing information.

Previous
Prefix
Next
Sampling
What is tokenization?
v3 (tekken) tokenizer
Our tokenization vocabulary
Run our tokenizer in Python
v3 tokenizer
Our tokenization vocabulary
Run our tokenizer in Python
Use cases
NLP tasks
Tokens count
Documentation
Documentation
Contributing
Community
Discord
X
GitHub
Copyright © 2025 Mistral AI.

Skip to main content
Mistral AI Logo
Le Chat
La Plateforme
Docs
API
GitHub
Discord

Search ⌘+K
Getting Started
Introduction
Quickstart
Models

Benchmarks
Model selection
Model weights
Clients
Model customization
Developer examples
Changelog
Glossary
Capabilities
Text and Chat Completions
Vision
Audio & Transcription
Reasoning
Document AI

Basic OCR
Annotations
Document QnA
Coding
Embeddings

Text Embeddings
Code Embeddings
Function calling
Citations and References
Structured Output

Custom
JSON mode
Moderation
Finetuning

Classifier Factory
Text & Vision Fine-tuning
Batch Inference
Predicted outputs
Agents
Introduction
Agents & Conversations
Connectors

MCP
Function Calling
Handoffs
Deployment
La Plateforme

Cloud

Self-deployment

Guides
Prompting capabilities
Basic RAG
Prefix
Tokenization
Sampling
Fine-tuning
Evaluation
Observability
Other resources
How to contribute

Sampling
Sampling: Overview on our sampling settings
Here, we will discuss the sampling settings that influence the output of Large Language Models (LLMs). This guide covers parameters such as Temperature, N, Top P, Presence Penalty, and Frequency Penalty, and explains how to adjust them. Whether you aim to generate creative content or ensure accurate responses, understanding these settings is key.

Let's explore each parameter and learn how to fine-tune LLM outputs effectively.

N Completions
N Completions
N represents the number of completions to return for each request. This parameter is useful when you want to generate multiple responses for a single input. Each completion will be a unique response generated by the model, providing a variety of outputs to choose from.

Key Points
Multiple Responses: By setting N to a value greater than 1, you can get multiple responses for the same input.
Cost Efficiency: Input tokens are only billed once, regardless of the number of completions requested. This makes it cost-effective to explore different possibilities.
Example
Here's an example of how to use the N parameter in the API:

import os
from mistralai import Mistral

api_key = os.environ["MISTRAL_API_KEY"]
model = "ministral-3b-latest"

client = Mistral(api_key=api_key)

chat_response = client.chat.complete(
    model=model,
    messages=[
        {
            "role": "user",
            "content": "What is the best mythical creature? Answer with a single word.",
        },
    ],
    temperature = 1, # Increasing randomness and diversity of the output, this is required to be higher than 0 to have diverse outputs
    n = 10 # Number of completions
)

for i, choice in enumerate(chat_response.choices):
    print(choice.message.content)

Output
Phoenix.
Dragon
Dragon
Unicorn
Unicorn
Phoenix
Unicorn
Dragon
Dragon.
Unicorn

In this example, the model generates 10 responses for the same input prompt. This allows you to see a variety of possible answers and choose the one that best fits your needs.

Temperature
Temperature
Temperature in Large Language Models (LLMs) controls output diversity. Lower values make the model more deterministic, focusing on likely responses for accuracy. Higher values increase creativity and diversity. During text generation, LLMs predict tokens with associated probabilities using a softmax function. Temperature scales these probabilities: higher temperatures flatten the distribution, making outputs more varied, while lower temperatures amplify differences, favoring more likely tokens.

Visualization
To better understand the underlying principle and impact it has on the probability distribution, here is a visualisation of the Temperature with a simple prompt: "What is the best mythical creature? Answer with a single word."

Example ImageBarplot example comparing the distribution with different Temperature values and the top 5 tokens using Mistral 7B at 4 bits precision.
Temperature significantly affects the probability distribution in LLMs. At a Temperature of 0, the model always outputs the most likely token, e.g., "Dragon". Increasing the Temperature to 0.2 introduces variability, allowing for tokens like "Un" (as in "Unicorn"). Further increases reveal more diverse tokens: the third token might still be "Drag" (for "Dragon"), but the fourth could start "Pegasus", and the fifth, "Phoenix". Higher Temperatures make less likely tokens more probable, enhancing the diversity of the model's output.

API
You can set a temperature value easily via our clients, let's experiment with our API.

import os
from mistralai import Mistral

api_key = os.environ["MISTRAL_API_KEY"]
model = "ministral-3b-latest"

client = Mistral(api_key=api_key)

chat_response = client.chat.complete(
    model = model,
    messages = [
        {
            "role": "user",
            "content": "What is the best mythical creature? Answer with a single word.",
        },
    ],
    temperature = 0.1,
    n = 10
)

for i, choice in enumerate(chat_response.choices):
    print(choice.message.content)

Dragon
Dragon
Dragon
Dragon
Dragon
Dragon
Dragon
Dragon
Dragon
Dragon

The model answered mostly with Dragon! Lets try with a higher temperature to try to have more diverse outputs, let's set it to temperature = 1.

Unicorn
Dragon
Phoenix
Unicorn
Dragon
Phoenix.
Dragon.
Phoenix
Dragon
Unicorn.

The outputs ended much more diverse, the model answering with a different creature more frequently, we have "Dragon", "Unicorn" and "Phoenix".

The Best Temperature
There's no one-size-fits-all Temperature for all use cases, but some guidelines can help you find the best for your applications.

Determinism
Requirements: Tasks needing consistent, accurate responses, such as Mathematics, Classification, Healthcare, or Reasoning.
Temperature: Use very low values, sometimes not null to add slight uniqueness.
For example, a classification agent should use a Temperature of 0 to always pick the best token. A math chat assistant might use very low Temperature values to avoid repetition while maintaining accuracy.

Creativity
Requirements: Tasks needing diverse, unique text, like brainstorming, writing novels, creating slogans, or roleplaying.
Temperature: Use high values, but avoid excessively high Temperatures to prevent randomness and nonsense outputs.
Consider the trade-off: higher Temperatures increase creativity but may decrease quality and accuracy.

Top P
Top P
Top P is a setting that limits the tokens considered by a language model based on a probability threshold. It helps focus on the most likely tokens, improving output quality.

Visualization
For these examples, we set the Temperature first, then apply a Top P of 50%. Note that a Temperature of 0 is deterministic, making Top P irrelevant in that case.

The process is as follows:

Apply the Temperature.
Use Top P (0.5) to keep only the most likely tokens.
Adjust the probabilities of the remaining tokens.
We will visualize the token probability distribution across different temperature values for the question:

"What is the best mythical creature? Answer with a single word."
Example Image
Different Temperature values and the top 5 tokens using Mistral 7B at 4 bits precision.
↓
Example Image
Top P considers only the top tokens until reaching 50% probability.
↓
Example Image
Other tokens' probabilities are set to 0, and the remaining tokens' probabilities are adjusted.
Top P ensures that only high-quality tokens are considered, maintaining output quality by excluding unlikely tokens. It's challenging to balance Temperature and Top P, so it's recommended to fix one and adjust the other. However you should experiment to find the best settings for your use case!

To Summarize
Role of Top P: Top P limits the tokens considered based on a probability threshold, focusing on the most likely tokens to improve output quality.
Interaction with Temperature: Top P is applied after Temperature.
Impact on Outputs: Top P avoids considering very unlikely tokens, maintaining output quality and coherence.
Balancing Temperature and Top P: It's challenging to balance both. Start by fixing one parameter and adjust the other, experiment to find optimal settings.
Example
Here's an example of how to use the Top P parameter with our python client:

import os
from mistralai import Mistral

api_key = os.environ["MISTRAL_API_KEY"]
model = "ministral-3b-latest"

client = Mistral(api_key=api_key)

chat_response = client.chat.complete(
    model=model,
    messages=[
        {
            "role": "user",
            "content": "What is the best mythical creature? Answer with a single word.",
        },
    ],
    temperature=1,
    top_p=0.5,
    n=10
)

for i, choice in enumerate(chat_response.choices):
    print(choice.message.content)

Output
Unicorn
Unicorn
Unicorn
Unicorn
Dragon
Unicorn
Dragon
Dragon
Dragon
Dragon

Output Table
Temperature 0.1	Temperature 1	Temperature 1 & Top P 50%
Dragon	Unicorn	Unicorn
Dragon	Dragon	Unicorn
Dragon	Phoenix	Unicorn
Dragon	Unicorn	Unicorn
Dragon	Dragon	Dragon
Dragon	Phoenix.	Unicorn
Dragon	Dragon.	Dragon
Dragon	Phoenix	Dragon
Dragon	Dragon	Dragon
Dragon	Unicorn.	Dragon
In this example, the model generates a response considering only the top tokens that cumulatively reach a 50% probability threshold. This ensures that the output keeps some uniform diversity while still taking only the best tokens, in this case only 2 tokens reach the 50% threshold.

Penalties
Previous
Tokenization
Next
Fine-tuning
N Completions
Key Points
Example
Output
Temperature
Visualization
API
The Best Temperature
Determinism
Creativity
Visualization
To Summarize
Example
Output
Output Table
Presence Penalty
Frequency Penalty
Differences Between Presence Penalty and Frequency Penalty
Example Without Presence Penalty
Output Without Presence Penalty
Example With Presence Penalty
Output With Presence Penalty
Example With Frequency Penalty
Output With Frequency Penalty
Documentation
Documentation
Contributing
Community
Discord
X
GitHub
Copyright © 2025 Mistral AI.